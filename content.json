[{"title":"计网课程设计DNS服务器","date":"2019-07-07T17:58:04.000Z","path":"2019/07/07/计网课程设计DNS服务器/","text":"为了分散平时的课业压力，计网课程设计选了小学期，不过课程内容都是一样的。 要写一个DNS服务器。提供一个A记录列表，要求对于本地存在的记录，若查询结果为0.0.0.0，返回NX_DOMAIN，其他结果正常返回。对于本地处理不了的请求，转发到另一个DNS服务器进行递归查询。要求支持并发查询 如果仅仅简单的完成功能的话，不需要对于报文进行完整的解读，只需要简单的看下ID，读下query看看能不能处理，然后组个只有一个RR的包就可以了。远程DNS服务器发回来的包也不需要仔细解读，只需要取报文前两个字节做下ID转换就行了。 若要进行更为细致的解读，则需要支持域名标识符解压功能，因为绝大多数DNS服务器在返回结果的时候，都会重用域名标识符后缀来进行压缩。除此之外，支持压缩功能也是极好，因为有的DNS服务器在查询一些CDN域名的时候，会返回10多条RR记录，解压之后无压缩重新组包会轻而易举的越过DNS报文512字节的限制，从而导致Malformed Packet。 在为DNS服务器添加cache功能的时候，我发现了一个有意思的现象：我看过的所有具有多个RR的DNS应答报文，RR的TTL都是相同的。与其他同学交流后发现，有的同学看到了不同TTL的DNS应答报文。上网查询资料，RFC 2181 Section 5.2里面是这么说的 Resource Records also have a time to live (TTL). It is possible for the RRs in an RRSet to have different TTLs. No uses for this have been found that cannot be better accomplished in other ways. This can, however, cause partial replies (not marked “truncated”) from a caching server, where the TTLs for some but not all the RRs in the RRSet have expired. Consequently the use of differing TTLs in an RRSet is hereby deprecated, the TTLs of all RRs in an RRSet must be the same. 也就是说TTL最好是一样的，于是我就大胆假设我们用的上级服务器是遵守了RFC 2181中的建议，随便从RRSet当中抽了一个RR中的TTL当成整个应答报文的TTL（一般只要TTL错的不是特别离谱，就不会影响DNS服务器的功能性）。 在实际的代码编写与调试当中，我遇到了不同线程的DNS报文对象中的一部分数据“窜”线程的现象。trouble shoot一下午发现原来是碰到了python的默认参数陷阱。在所有的类的构造函数中都把参数深拷贝一份，就把问题解决了。 未完待续","tags":[{"name":"狗课","slug":"狗课","permalink":"http://cjsoft.github.io/tags/狗课/"}]},{"title":"操作系统进程同步实验","date":"2019-05-20T14:25:03.000Z","path":"2019/05/20/操作系统进程同步实验/","text":"最近在写操作系统的进程同步实验，现在随便写点什么。实验基于川和秀实的《30天自制操作系统》的day24f代码，也就是进行代码分文件夹归类的最后一版。 要求分析： 实现系统内核态的共享变量竞争条件 实现系统内核态的共享变量竞争条件的解决方案，并进一步实现某一个同步场景 实现从用户态启动前两条内容 基于30天实现展示用户程序中逻辑地址到物理地址的转换 第一个。30天OS中的任务调度是以TASK为单位的，若要实现竞争条件，可以建立两个及以上数量的TASK，对同一个变量进行进行自加操作，检测自加前后的差值，如果大于1，那么就说明变量中间被别的TASK访问过。 在实现的时候，我发现要出现竞争条件很难，所以我在自加之后加了一个长度为5的循环，这样就很容易出现竞争条件了。 第二个。我重新整理了一下代码，做了一个sync_utils库。里面提供了一个快速创建任务的函数，以及原子的test_and_set、Swap、sem_wait、sem_signal。注意任何while的阻塞循环都应当io_hlt()，否则会一直占用CPU。利用这些函数，实现了一个生产者消费者的进程同步模型。 剩下两个还没整。 附一下sync_utils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* sync_utils.c *//* 记得修改Makefile和bootpack.h */#include \"bootpack.h\"void avoid_sleep() &#123; struct TASK *now_task; now_task = task_now(); now_task-&gt;flags = 2;&#125;int test_and_set(int *target) &#123; io_cli(); int tmp = *target; *target = 0xff; io_sti(); return tmp;&#125;void Swap(int *a, int *b) &#123; io_cli(); int tmp = *a; *a = *b; *b = tmp; io_sti();&#125;void sem_signal(int *x) &#123; io_cli(); (*x)++; io_sti();&#125;void sem_wait(int *x) &#123; while ((*x) &lt;= 0) io_hlt(); io_cli(); (*x)--; io_sti();&#125;struct TASK *create_task(struct MEMMAN *man, void (*f)(void *), void *args) &#123; struct TASK *tst = task_alloc(); tst-&gt;cons_stack = memman_alloc_4k(man, 64 * 1024); tst-&gt;tss.esp = tst-&gt;cons_stack + 64 * 1024 - 8; tst-&gt;tss.eip = (int)f; tst-&gt;tss.es = 1 * 8; tst-&gt;tss.cs = 2 * 8; tst-&gt;tss.ss = 1 * 8; tst-&gt;tss.ds = 1 * 8; tst-&gt;tss.fs = 1 * 8; tst-&gt;tss.gs = 1 * 8; *((int *)(tst-&gt;tss.esp + 4)) = (int)args; return tst;&#125; 用法示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394struct BBParg &#123; // 参数类型 int *empty, *mutex, *full, id; int *con_mutex; struct FIFO32 *fifo; struct TASK *task;&#125;;void producer(struct BBParg *args) &#123; avoid_sleep(); int *empty = args-&gt;empty, *mutex = args-&gt;mutex, *full = args-&gt;full, id = args-&gt;id; struct FIFO32 *fifo = args-&gt;fifo; struct TASK *task = args-&gt;task; int cnt = 2, i; char tag; char str[128]; while (1) &#123; tag = 0; while (!tag) &#123; tag = 1; for (i = 2; i * i &lt;= cnt; i++) &#123; if (cnt % i == 0) &#123; tag = 0; break; &#125; &#125; if (!tag) cnt++; if (cnt &gt; 0x3f3f3f) cnt = 2; &#125; sem_wait(empty); sem_wait(mutex); fifo32_put(fifo, cnt++); sem_signal(mutex); sem_signal(full); &#125;&#125;void consumer(struct BBParg *args) &#123; avoid_sleep(); int *empty = args-&gt;empty, *mutex = args-&gt;mutex, *full = args-&gt;full, id = args-&gt;id, *con_mutex = args-&gt;con_mutex; struct FIFO32 *fifo = args-&gt;fifo; struct TASK *task = args-&gt;task; int tmp; char str[128]; while (1) &#123; while (task-&gt;cons == 0) io_hlt(); sem_wait(full); sem_wait(mutex); tmp = fifo32_get(fifo); sem_signal(mutex); sem_signal(empty); sprintf(str, \"cproc %d fetched %d\\n\", id, tmp); sem_wait(con_mutex); cons_putstr0(task-&gt;cons, str); sem_signal(con_mutex); &#125;&#125;/* in HariMain */struct SHEET *sout;sout = open_console(shtctl, memtotal);sheet_slide(sout, 64, 4);sheet_updown(sout, shtctl-&gt;top);/* 进程创建参数 */struct BBParg agp, agc1, agc2;int buf[128];struct FIFO32 bbpfifo;fifo32_init(&amp;bbpfifo, 8, buf, 0);struct TASK *tskp, *tskc1, *tskc2;int empty = 8, mutex = 1, full = 0;int con_mutex = 1;agp.empty = &amp;empty;agp.full = &amp;full;agp.mutex = &amp;mutex;agp.fifo = &amp;bbpfifo;agp.con_mutex = &amp;con_mutex;agc1 = agc2 = agp;agc1.id = 1;agc2.id = 2;agc1.task = key_win-&gt;task; // 第一个consumer将在第一个console中进行输出agc2.task = sout-&gt;task; // 第二个consumer将在第二个console中进行输出/* 创建进程 */tskp = create_task(memman, &amp;producer, (void*)&amp;agp);tskc1 = create_task(memman, &amp;consumer, (void*)&amp;agc1);tskc2 = create_task(memman, &amp;consumer, (void*)&amp;agc2);/* 运行进程 */task_run(tskp, 2, 0);task_run(tskc1, 2, 0);task_run(tskc2, 2, 0);","tags":[{"name":"狗课","slug":"狗课","permalink":"http://cjsoft.github.io/tags/狗课/"}]},{"title":"循环赛日程表问题报告","date":"2019-04-01T09:25:17.000Z","path":"2019/04/01/tournament/","text":"循环赛日程表问题报告先来想想问题的约束条件 我们要输出这么一张表 如果n是奇数，则表是n行n列的，第j列包含除去j以外的所有从1到n的数字，除此之外还包括一个0（表示不参赛）。同一行中一个数字最多只能出现一次，可以不出现。 如果n是偶数，则表是n-1行n列的，第j列包含除去j以外的所有从1到n的数字。同一行中一个数字最多只能出现一次，可以不出现。 我们先考虑一下分治怎么做。特殊情况下例如n为2的次幂的做法，我们已经在课堂上学过了。我们唯一要解决的是遇到奇数怎么办。很显然，对于奇数子问题，每天都会有一个人可以休息，不需要打比赛，为了让问题可以使用相近的办法处理，我们很容易的就想到了引入一个虚拟的玩家来陪这个人玩的方法。很显然这个引入的虚拟玩家不会在一天之内重复比赛，也不会与某个人重复多次比赛。仍然满足循环赛的性质。剩下的就和课堂上学的普通循环赛做法差不多了。 分析一波复杂度。递归$\\log{N}$次，每次copy来copy去的与$N^2$同阶。总复杂度$O(N^2\\log{N})$。 emmm，可是这张表的大小才$N^2$这么大啊，我们不能把这个$\\log{N}$给去掉吗？可是只要我们进行分治，并且每次都要copy的话，这个复杂度肯定就下不来。去掉copy部分？好像有点难。 不过我们何必局限于分治呢？我们直接想其他办法逼近下届$(N^2)$不好么？ 通过画图，我发现一个很棒的性质。对于奇数个玩家，如果把他们画成一个圈，遍历每个玩家，所产生的角点反射，正好构成了一个符合循环赛性质的置换集合。 以1为角的角点反射 应用这个性质，我们很快就能够写出第一版，只支持计数的循环赛日程安排程序。 我们再考虑n为偶数的时候，我们还能够应用和刚刚类似的方法去进行日程安排吗？ 很遗憾，不能。 n为偶数的时候，总共有2n种反射方案，这2n种方案显然要进行一定的筛选才有可能生成一个可行的解，别扭不优雅。我们可以换种思路，结合一下分治做法当中引入虚拟玩家的思想，我们把偶数个的合法玩家中的一个先给踢出去，一会再想办法给他弄回来。这样问题就转化成为了在奇数个玩家种安排日程表的问题了，是我们刚刚已经解决的问题，我们可以套用那个算法。 好，现在我们考虑如何把刚刚踢出去的玩家再给弄回来。奇数情况下的算法中，每个人至少会休息一天，那天没人和他比赛，那我们不妨让这个被踢出去的玩家在那些天比赛。由于这些0在一列当中只出现一次，在一行当中也只出现一次，把他替换成我们刚刚踢出去的玩家并不会破坏循环赛的性质，我们就给他加进去好了。 emmm，问题好像就这么解决了？ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define MXN 107using namespace std;int n, days;int arr[MXN * 3];int vs[MXN][MXN];void work(int n) &#123; days = (n &amp; 1) ? n : n - 1; for (int i = 0; i &lt; days; ++i) &#123; arr[i] = arr[i + days] = arr[i + days * 2] = i + 1; &#125; for (int i = 0; i &lt; days; ++i) &#123; for (int j = 1; j &lt;= days / 2; ++j) &#123; vs[i][arr[days + i - j]] = arr[days + i + j]; vs[i][arr[days + i + j]] = arr[days + i - j]; &#125; &#125; if ((n &amp; 1) == 0) &#123; for (int i = 0; i &lt; days; ++i) &#123; vs[i][i + 1] = n; vs[i][n] = i + 1; &#125; &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); work(n); printf(\"Player : \"); for (int i = 1; i &lt;= n; ++i) &#123; printf(\"%4d\", i); &#125; putchar('\\n'); for (int i = 0; i &lt; days; ++i) &#123; printf(\"Day #%2d: \", i + 1); for (int j = 1; j &lt;= n; ++j) &#123; printf(\"%4d\", vs[i][j]); &#125; putchar('\\n'); &#125;&#125;","tags":[{"name":"实验报告","slug":"实验报告","permalink":"http://cjsoft.github.io/tags/实验报告/"}]},{"title":"三种排序算法评价报告","date":"2019-04-01T09:06:26.000Z","path":"2019/04/01/three-sort-algos/","text":"三种排序算法评价报告介绍测试工具集清单1./data&#10;./gen.py&#10;./gen.sh&#10;./main.cpp&#10;./Makefile&#10;./std.cpp&#10;./test.sh 文件名 功能 Makefile 控制整个测试流程 gen.py 用于生成不同的测试输入 gen.sh 控制测试输入生成以及正确答案的输出 std.cpp 用stl sort实现的标准答案 main.cpp 待测试程序 test.sh 控制测试流程 用法以下在Ubuntu 18.04中可正常运行，Debian系发行版应该都能够正常运行，WSL上测试亦通过。需要GNU Make工具、g++以及python2 make自动执行整个测试流程，并输出结果到标准输出 make binary编译使用三种不同算法的排序程序，并编译标准程序std make std只编译标准程序std make testcase生成n为100到100000，梯度为10倍，分别具有随机、降序、升序三种特征共12组数据，并调用std生成答案 make test调用三种不同算法实现的排序程序对数据进行排序，工具会检查排序结果的正确性并输出腾挪/赋值次数和比较次数 样例输出及注释make 1100&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;# &#27492;&#32452;&#27979;&#35797;&#25968;&#25454;&#22823;&#23567;&#20026;100&#10;qsort r AC 304 966&#9;# &#24555;&#36895;&#25490;&#24207; &#25968;&#25454;&#29305;&#24449;&#20026;&#38543;&#26426; &#32467;&#26524;&#27491;&#30830; &#33150;&#25386;/&#36171;&#20540;&#27425;&#25968;&#20026;304&#65292;&#27604;&#36739;&#27425;&#25968;&#20026;966&#10;msort r AC 1344 547&#10;isort r AC 2792 2785&#10;qsort i AC 297 4950&#10;msort i AC 1344 356&#9;# &#24402;&#24182;&#25490;&#24207; &#25968;&#25454;&#29305;&#24449;&#20026;&#21319;&#24207;&#10;isort i AC 200 199&#10;qsort d AC 297 5000&#10;msort d AC 1344 316&#10;isort d AC 5150 5050&#9;# &#25554;&#20837;&#25490;&#24207; &#25968;&#25454;&#29305;&#24449;&#20026;&#38477;&#24207;&#10;&#10;&#10;1000&#10;qsort r AC 3765 14420&#10;msort r AC 19952 8680&#10;isort r AC 255907 255900&#10;qsort i AC 2997 499500&#10;msort i AC 19952 5044&#10;isort i AC 2000 1999&#10;qsort d AC 2997 500000&#10;msort d AC 19952 4932&#10;isort d AC 501500 500500&#10;&#10;&#10;10000&#10;qsort r AC 44992 206306&#10;msort r AC 267232 120428&#10;isort r AC 25148189 25148181&#10;qsort i AC 29997 49995000&#10;msort i AC 267232 69008&#10;isort i AC 20000 19999&#10;qsort d AC 29997 50000000&#10;msort d AC 267232 64608&#10;isort d AC 50015000 50005000&#10;&#10;&#10;100000&#10;qsort r AC 523928 2705930&#10;msort r AC 3337856 1536236&#10;isort r AC 2493173305 2493173289&#10;qsort i AC 299988 4999851629&#10;msort i AC 3337856 853904&#10;isort i AC 200000 199999&#10;qsort d AC 299987 4999916606&#10;msort d AC 3337856 815027&#10;isort d AC 5000149995 5000050000 用于定数循环控制的比较次数并没有被包括在内，统计仅包含了用于决定是否对元素进行操作的那些比较。 结果汇总及分析https://docs.google.com/spreadsheets/d/1h71QwPLw74WROPpCvIguCgVzClfowX6lOD2USxLbse4/edit?usp=sharing 或见内附的算法实验.xlsx 或内附的table.html 我们可以看到最基础的快速排序的比较次数在随机数据（平均情况）下增长速度约为数据每增大10倍，比较次数约增大14倍，腾挪次数约增大12倍。在升序和降序数据下，腾挪次数/赋值次数增长速度约为10倍，而比较次数则变成了惊人的100倍。而这也正是我们这种快速排序的最坏情况，复杂度退化到$O(n^2)$。 我们再看归并排序，我们发现两个统计量的增长速率都是13、14的样子，而且相同数据大小的情况下，无论数据具有什么样的特征，赋值次数都是相同的，这是因为无论数据具有什么特征，都会被放入并拿出辅助数组$\\log_2{n}$遍，我们可以由此给出估算式子$count=2n\\times\\log_2{n}$。而比较次数在随机数据下没有明显特征，但一定是$O(n\\log{n})$的。在升序或降序条件（也许这可以算是一种最好情况？）下由于每次合并的时候比较总是比较半个区间长度次数就把左面的区间段归位了，右面的直接无脑放入就可以了，所以也应该是$O(n\\log{n})$的，我们能给出估算式子$count=\\frac{1}{2}n\\times\\log_2{n}$。由于归并排序的性质，他的运行时间相当稳定，对于他来说没有什么最好情况、最坏情况。 最后再来看插入排序，我们发现插入排序的比较次数和赋值次数增长速率相同。随机数据（平均情况）下均为96，降序条件下均为99，升序条件下均位10。升序条件（最好情况）如此与众不同的原因是我们是从后往前插入的，检查的第一个位置就是正确的位置，插入也不需要移动整段序列，所以每次插入都是$O(1)$的，故最好情况下复杂度为$O(n)$。 这个最好情况跟插排的具体实现息息相关，如果是从前往后找插入位置的话，那么复杂度还是$O(n^2)$ 这个版本的插入排序的最坏情况就是降序，增长速度达到了99，不过也不是很糟，随机数据的增长速度都有96了呢。 总结对最终结果的评价要以两个统计量的较大者为标准。 我们发现快速排序和归并排序在平均情况下表现差不多，感觉归并还要更好一点，但实际上由于归并不是原地排序，常数会大一些。需要注意的是，这个快排的实现是最裸的，pivot的选取还有随机选、首中尾取中位数等选法，表现会比这个版本的更好。尤其是遇到有序数组的时候，这些pivot选法将避免复杂度退化到$O(n^2)$。 一个好的排序算法会综合各种排序算法的优点，所以不可以简单的断言快排是最好的排序算法。 后记为什么不测时？ 测时间无外乎一下几种做法 利用shell的built-in的time进行时间测定 利用系统提供的time工具进行时间测定 运行程序前后系统时间作差 利用time.h中的clock进行测时 其中1、2的时间粒度都比较迷，基本上都是10ms的，虽然说足以体现运行的差异，但是会把读入数据的时间也计算在内，不是很好。 方法3的时间粒度可以很细，可以到μSec，但是依然面临会把非核心算法的计算时间也放在里面的这种问题。 至于方法4，方法4不知道到底是谁问题，测定的结果非常迷，经常是0，而且多次测量结果还经常有差别，我觉得是最不靠谱的测定方法。 对于这种输入数据较大的问题，我们所关心的是核心算法的时间复杂度，而不是很关心读入数据输出数据啥的用了多少时间。而我们所写的确定性算法的核心步骤的运行时间往往与赋值、比较操作的次数有一个比较稳定的比例关系，鉴于clock()的不靠谱，我们用这些参数取一个最大值来衡量算法的时间复杂度还是比较靠谱的。最重要的是：同一组数据多次运行，这些参数的结果都是一样的，而不是会和运行时间一样，受到计算机性能波动的影响。如果是比较运行时间增长速度的话，则更加靠谱了，我们比较一下参数的增长速度和数据集大小的增长速度，大概就能估算出这个算法运行时间的增长到底是什么样子的了。","tags":[{"name":"实验报告","slug":"实验报告","permalink":"http://cjsoft.github.io/tags/实验报告/"}]},{"title":"CCPC桂林站","date":"2018-10-28T14:22:38.000Z","path":"2018/10/28/CCPC桂林站/","text":"CCPC桂林站坑先留着","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"ICPC沈阳","date":"2018-10-21T14:22:38.000Z","path":"2018/10/21/ICPC沈阳站/","text":"ICPC沈阳站坑先留着 衣服很丑 惯例，随便填填 1.对题目的分析：A:B:C: 打表找规律题D:E: 二维平面不同集合最远点对。不会做F:G: 维护二维整点图上的一些信息。暴力搞就好了H:I:J: 签到题，解析字符串然后做点四则运算就行了K: 约瑟夫衍生题目，场上没做出来L: 计算几何，求求交点，分类讨论，暴力乱搞就能过了，然而场上并没过M: 2.对出题单位风格的分析： 3.比赛过程和策略回溯：读题读的比较慢，我们三个的开题策略是于珺泽从前开，房庆凯从中间，我从后向前开。没能快速找到签到题，签到题是第41分钟跟榜做才过的。然后C、G题过得都挺顺利。接着自闭了一段时间，三个人开始打D、E、H、G、L的主意。自闭期间，房庆凯猜了D的一发结论，写了个找两次重心的贪心交上去，WA掉。G是个推数列的题，然而我们都没太看懂题意，不过样例给出了前四项，我就去查OEIS，发现前四项符合的数列挺多，浏览了好几遍，似乎并没有题目的数列，看不懂题意又不能手玩出第5项，也放弃掉了这道题。H题没啥特别的想法。最后我们把目光放到了L题。L题预先想了个O(n log(n))的做法，大致就是求交点凸包然后卡壳一波得到最远点对，然后再讨论讨论。一开始讨论的并不十分完全，由于时间较为紧张，所以就先写了。我看到数据比较小，n为100，想O(n^2)暴力，然而看到5000个case这个条件的时候，感到时间比较紧张，三个人讨论了一下，决定写O(n log(n))的（我们想当然的认为这些题目和大部分的OI题一样是1s的时限）。此时算法还未完全成型，还是直接让房庆凯上了。写到最后发现时间不太够了，搞出个低复杂度的讨论有些难，于是还是直接上了O(n^2)的暴力判断，然而之前算最远点对的凸包卡壳还是没有换掉，这部分应该是出了问题，最后20分钟疯狂WA。恩。然后赛后知道这个题目是6秒时限，2G内存。如果我们一开始就决定写暴力的话，是有极大概率快速一次过掉这个题的，有机会获得金末 4.比赛现场发挥：前半场历程虽然不是十分顺利，但是还是比较稳的，没造成特别巨大的罚时。后半场在众多貌似可做但不是特别可做的题目中有些迷失，没有第一时间决定肝最可做的L题。另外由于读题上的失误，导致了L题一开始的错误方向，最后没能及时纠正，没能过掉这道题。总体来说发挥还是欠佳的。5.本场比赛得失：得到了又一个教训：读题要注意时限和空间 6.其它建议或意见吐槽比赛题面：为什么纸质题面上不印上时限和空间限制！谁没事单独再去OJ上扒拉题目信息看啊。当然这也是我们的锅，没搞清楚时限就想当然的开始写，加上时间紧张导致代码出错，本来也应该能AC掉的题最后WA到结束。一定一定一定要看时限！","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"ICPC南京站","date":"2018-10-14T14:22:38.000Z","path":"2018/10/14/ICPC南京站/","text":"ICPC南京站坑先留着 坑随便填填，就填个赛后总结吧 1.对题目的分析：A: 博弈签到题，直接两三个if就好了B:C:D: 最小球覆盖的板子题E:F: 与图上路径序列有关，不会做G: 计数推式子题H:I: 带限制的最大流，加两个附加源点J: 计数，每个质数算贡献K: 正常做法应该是先合并袋鼠，然后再一起跑bfs。不过据说大力随机一发是可以过的L:M: 扩展kmp+回文自动机 2.对出题单位风格的分析：各种题目都有，感觉没有明显的特点。 3.比赛过程和策略回溯：三个人分别读题，先开了A，大力猜了一发结论，交，WA，发现读错题意了。之后慢慢开了J题和I题，分别过了。此时A已经被全场A的差不多了，由于WA过一发，就不敢乱猜了，于是三个人开始对着A自闭。自闭不出来，两人开其他题，留一人手玩A，玩了几个小数据之后发现好像几个if就行了，于是又猜了一发交上去，A了A题。接着开了G，和D，发现D题没！带！板！子！G题推的式子有问题，WA（结束比赛几分钟之后才调正确），M题后来写的KMP和PAM，狂T不止。 4.比赛现场发挥：A题如果是正常顺利的AC的话，历程应该是：看题意，手玩小数据，猜结论，证明结论[可选]，写题并提交，然而我是直接猜了一发结论，完蛋。这个WA直接导致面对A题心态稍微有点自闭，以至于开场两小时之后才A掉签到题。整场比赛并不是十分的顺利。结束后出榜前，甚至都不知道能不能有铜。 5.本场比赛得失：得：得到了后文中提到的教训失：如果资料带够的话，是有相当大的机会快速过掉A、D、G题的。然而之后的几场比赛都没有这么好的机会了，题目与准备的资料高度重合，机会不再有！（然而就算过了也就是个银） 6.其它建议或意见赛前我爬取了OEIS的前5w个数列并进行了清洗，之前想打印出来并带去比赛。但感觉有点多有点沉就没带，后来发现G题的数列就在这些清洗过的数列之中，也就是说如果带了这些数列的话，应该是可以较为轻松的过掉G题的。除此之外，小红书里就有最小球覆盖的板，然而我们既没有带小红书，也没有准备最小球覆盖的板子，GG。白书挑战中的博弈例题与A题高度相似，如果带了白书的话，应该可以快速从自闭状态脱离并猜出正确的结论。综上，板子、资料别嫌沉，觉得有点用就带着吧。赛前完全没有联系过，所以可能比赛的时候节奏不太好，希望下次能够注意。","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"选站通告","date":"2018-09-26T07:24:30.000Z","path":"2018/09/26/选站通告/","text":"前言18赛季的训练阶段很快就结束了，经过8场多校和若干场网预赛之后，我们莫名其妙的在第一次选站会前变成了北邮二队。 第一次选站会于是我们很兴奋的先选了ICPC南京站（10月13日~10月14日）和CCPC桂林站（10月27日~10月28日）。南京站在南京航空航天大学举办，桂林站在桂林电子科技大学举办。 爆炸然后又经过了两场网预赛，这是两场原地爆炸的网赛，我们从二队掉成了四队（/小纠结）。 第二次选站会然后是第二次选站会，我们选了ICPC沈阳站（10月20日~10月21日），沈阳站在东北大学举办。 小算盘按照一天180元的交通补助，每站三天，扣除可能的其他费用，10月份大概可能净赚1000+元（前提是任何一站都没有打铁）。学校不报销桂林站的返程机票费用，只给报销硬卧（虽然只贵了200元），预计路上时间20+h。 队名“阿訇念经，嘤嘤嘤嘤”Akhund read the the Koran, (ying){4} /小纠结 后记蛮喜欢三个人打比赛的！","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"暑期集训小记0x00","date":"2018-07-30T02:40:23.000Z","path":"2018/07/30/暑期集训小记0x00/","text":"怎么来的7月21日我坐高铁从大连回到北京，一下车就再次感受到了北京的热情。坐地铁拖着箱子叮叮哐哐到了沙河站，骑车左手握把，右手拖箱子回到了凉爽的103。把衣服被子以及一些乱七八糟的生活用品塞进箱子之后，出发的准备就算完成了。次日叫了辆货拉拉，四个人若干个箱子一车走，来到了吸土城。 怎么安家的沃尔玛走了一波，买了盆桶液啥的乱七八糟的东西。去自提柜把床垫取了，回屋把床桌子椅子柜子抽屉架子杆子柜面蹭了，床垫铺上，褥子铺上，床单盖上，蚊帐挂上。算是搞定了。 干了点啥7月23日也就是来到吸土城的第二天，多校划水。 记不起来了，最近觉睡的有点多。。。 想大家了、","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"廿四一日游（流量告警）","date":"2018-07-19T03:11:27.000Z","path":"2018/07/19/廿四一日游（流量告警）/","text":"流量告警，这篇post里全是低压缩的照片，约51MB，加载时间可能较长！","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"王海涛布置的毕业作业","date":"2018-07-12T06:49:21.000Z","path":"2018/07/12/王海涛布置的毕业作业/","text":"随时更新暂时没有写完第一次更新于 2017-08-18 21:41:02第二次更新于 2018-07-12 14:49:21 廿四生活全记录（伪）前言从没想过毕业之后的生活是什么样的模板。大概是整日颓颓颓，糜烂又糜烂。做好的假期计划多半没法实现，雄心壮志在被窝中慢慢消散。 从没想过离开这座校园会带来什么样的改变。大概是许多校园中的熟人再也不见，许多校园景观只能在梦中怀念。卓越策划里尽是些新鲜的面孔，无人能把我的名字念。八点半的解放路不再有我的朋友们出现。四号车的师傅不再把车技练。 小考本，再见！沃森克里克，排列组合不再熟练。然而还有机会和王海涛见面。 景观篇老总控在卓越策划当苦力这三年来，我做的最多的事情就是蹲总控。在歌手大赛、学长学姐的成人仪式、高三联欢会、毕业典礼以及诸多我早已忘记的活动上，总控位就是我的座位。然而总控位多半情况下不是什么好的座位，场内总控最好，新总控其次，老总控最差。老总控在哪里？如果你站在舞台正中央，面朝后方，你可以看到左手边有一扇门。打开它，你能看到一个陡峭的楼梯（CAUTION STEEP STAIRS！这个楼梯曾经摔得我七荤八素），小心翼翼的爬上去，你的左手边有一扇门。bingo！这就是老总控了。 老总控观影指南：正常情况下，老总控是无法看到舞台的（如果你的眼睛足够好用，那么你可以透过那个单向玻璃看到舞台），那么总控的劳动人民如何才能欣赏到精彩的节目呢？老总控里有一台连接到报告厅微光监控的监控台。通过它，你可以第一时间欣赏到舞台上最精彩的节目。不过由于未知原因，监控台中的人物会变成大头娃娃。 其他关于老总控的有趣事实： 老总控中的温度对于我来说永远偏低（虽然新总控中也是这样） 掀开老总控的窗帘，你会看到窗外的美景 老总控里有一个报废了的塑料质感强烈的灯光控制台，看起来就像科技馆中的玩具一样 老总控里只有一台破电脑 老总控的旧电脑的视频线一定要插在显卡的口上，不要插主板（不要问我怎么知道的） 老总控里没有监控，你可以在里面做一些羞羞的事情 老总控位于报告厅，我这有一张2017年10月5日照的报告厅正门照片。 毕业之后第一个十一回校拍下的照片 卓越策划黑作坊黑作坊，贼船难下！先来几张镇楼图 屋里曾/现有各种宝贝： 一台报废了的3D打印机 线段钩他们班造的纸房子 火箭炮的玩具 木头人 李雨林那一届的名片（应该归类到火箭炮的玩具里去） 合影板（第二张镇楼图） 有线键鼠两套（我无偿贡献的我无偿贡献的我无偿贡献的）（向学校申请的有线键鼠两年了都没下来） 四年没擦过的白板 一台密码为（大连24毒奶智障）的路由器 为什么iMac不算宝贝？因为那五台iMac的配置对于现在来说太糟糕了，还是不要当宝贝的好。iMac的来历：队长（液晶屏）那届OI考的很好，学校一冲动就买了5台iMac。 当年周姐还经常给我发小红花呢，类似的截屏我存了好多呢我届（第三届）的卓越策划海报，把我的姓打错了 机房（以下机房均指五楼机房）机房曾是二十四中唯一有空调的教室。机房分里屋和外屋两大部分，外屋是教学区，里屋以前是钢哥卧室，现在是钢哥网吧。机房是我的第二教室。我们一群人坐在机房不靠谱的凳子上，用着不靠谱的电脑，用唯一靠谱的g++编译我们不靠谱的程序——这是我们不靠谱的校内赛的现场。 关于机房的几个有趣事实： 空调滤网似乎从来没有换过，吹出的风都是臭的 可以用ntsd -cq -pn studentmain.exe来关掉学生端（如果我没有记错的话） 以前上网是不用代理服务器的，交换机似乎出了问题 教师机的密码总是两个字母 里屋的床不是最开始的那张，最开始的那张被大梁压趴了 里屋的常客有张新钢老师、韩煜涛老师、李建玮老师以及网吧顾客 电闸上标识的靠窗指的是外面的窗而不是走廊的窗 于健豪曾经从里屋的狗窗爬进去过 随手左旋便条是我写的（不知道现在还在不在） 33是于队长的机子 200是我的机子（好像是） 教师端有个命令是远程蓝屏，是我添加的 钟楼钟楼是廿四学生人人向往的禁地，然而只有很少的人曾经到过钟楼。我有幸成为其中之一。钟楼在高二下半学期的一段时间内，没有上锁。极为偶然，我在一次离开电视台的路上发现了这个漏洞，于是拉着当时在电视台的各位去钟楼探秘。 曲径通幽处。想要到达钟楼，需要爬一段比较陡峭的楼梯。进入钟楼，顶层一台方形铁盒子跃入眼中。它被放置在正中央。 那台设备差不多长这个样子 王雨涵为我们那次钟楼之行留下了影像，但珍贵的影像流落到了众多图片之中，再也找不到了。 旧小卖铺小卖铺曾是廿四学生的圣地，位于高三楼地下一层，由一个哥哥和一个奶奶负责。尽管地下室非常的小，非常的闷热，但大家还是前赴后继的来到这里。 这里是观赏足球赛的绝佳场所。一手拿着鸡肉卷，一手拿着可乐瓶，看着操场上的人，实在是爽上加爽。 食堂 当我第二次更新的时候，已经是2018-07-12 14:49:21了 民以食为天，二十四中同学却并不以食堂为天。不知道初中的时候是谁告诉我二十四中食堂好吃的，这可真是个不美丽的谎言。对于食堂的饭菜，我仅有的评价是能吃、能吃饱。不过食堂的小楼还是值得说一说的。 摄于2017年10月5日，上面写着“24[校徽]中学”的建筑物就是食堂小楼非常遗憾，没有食堂内景照片 食堂的二楼对的是教学楼二楼，而食堂的三楼对的是教学楼四楼。食堂挺小的，二楼吃的是盘餐，毕业前现在已经涨价到11元了。同时二楼还拥有新小卖铺和饭卡充值处。三楼有麻辣烫、包子、奇怪面条。四楼最左面的窗口一定是茄子土豆加一个炸鸡块或者是一个鸡腿，其他窗口记不太清了。五楼是自选，品质大概和沙邮学食三楼五五开，半斤对八两吧！高三经常和朋友去五楼吃，两个人一人要一盘菜或者一个拼盘，然后大家混着一起吃。非常令人开心的回忆。雨天在食堂吃，阴天在食堂吃，晴天在食堂吃，都是些不同的体验。体育课提前去食堂吃，老师拖堂晚去食堂吃，感受也各不相同。 关于食堂的几个有趣事实： 墙上的多媒体终端曾经放过电视台剪的烂片，公开处刑！ 五楼以下的米饭都是免费的 老江刚开学，和同学们不熟，又忘记带饭卡，于是吃免费米饭和汤打发肚子 晚上的某个菜是用中午卖不出去的麻辣烫炒的 去的晚，阿姨会给你多打些菜（好像任何一所学校的食堂都是这样） 鱼池鱼池经过一次装修，里面有许多胆小肥硕的鱼，不知道能不能吃呢！ 让人看了很舒心的鱼池 画校友捐赠的画，不知道是谁画的，我很喜欢，右下角的签名应该是捐赠的校友名单。 摄于2017年10月5日 琴主教学楼一楼大厅有一架钢琴，中午午休的时候经常会有人过来弹，琴社也会在这里举办活动，邀请同学们点曲子。琴的周围也是一个张贴海报的地方。 摄于2017年10月5日 云舒亭一个高二下学期（似乎）开始有名字的小亭子。我曾经把它当成了舒露亭，我不知道我为啥除了最后一个字全没读对。云舒亭是我高一体活课时和别人聊天的时候最喜欢去的地方。感觉高一那个装修之前的云舒亭更有韵味。 摄于2017年10月5日 五爱碑五爱碑是二十四中的一个经典景观。三年来一直没有仔细的观察过五爱碑。 “爱祖国、爱人民、爱劳动、爱护公共财物，做为全体国民的公德来培养每一个学生”。 ——毛泽东 摄于2017年10月5日 作息钟作息钟是一个我毕业之后才开始喜欢的一个校园景观，高中的时候一直没对它有过太多的注意。它代表了一部分我在廿四所学到的生活习惯，“定时作息，养成规律生活”。可以说我大学能保证一个基本规律的生活，和这个作息钟多多少少还是有点关联的。 秋天的作息钟照片由亲爱的学妹李冰冰提供，摄于2017年10月19日夏的作息钟照片由我自己提供，摄于2018年6月2日 作息钟搭配着作为背景的爬山虎，看起来真的让人很舒心。 待更活动篇高中三年参与过不少的学校活动，拾取其中一二，回忆一番，或许会有新感受。 OIOI两年一场空，国赛一场见祖宗。 高一入坑之前对于OI究竟是怎样的，并没有一丝一毫的认识，只知道是一个可以打代码的竞赛。于是迫不及待地找钢哥入了坑。！！！又上了一条贼船！ 本来以为学OI可以天天写业务代码，没想到是天天学习玄学数学。碰上王志这样的，可能连贞洁都要不保。 从校内赛、两次NOIP、两次省选、APIO、CTSC一路走来，送走迎来了一个又一个人，深刻的意识到了自己是个蒟蒻的事实。PKUSC曾是我最接近国内顶尖学府的一次比赛，然而还是玩砸了（蒟蒻还是不要做梦了）。NOI最后拿了一个尴尬的，但是展现了自己真实水平的成绩，349，属于那种分数不够当场签协议的那种。 部分OI小组成员 歌手大赛上贼船的后果。 除了排练当天大晚上才能回家不能写作业最多洗个澡还要干些乱七八糟的活重新走一遍流程发发牢骚很晚才能睡之外，筹备歌手大赛这件事还是很有趣的。当然我只是一个蹲总控的。不过我这一届的总控位视角非常的棒。坐在总控专席上可以非常爽的看台上的表演，旁边还有灯光师在饶舌。 最后一次排练总控台现场 关于歌手大赛的几个有趣事实： 我写的通过侦测幻灯片并且可以控制播放进度的播放控件在入场前10分钟突然挂掉了，原因不明。后改用传统的音乐播放方式——幻灯片插入法。 二楼老总控里还蹲着兢兢业业的播放分数的关妈。 完事之后工作组又双叒叕去汉堡王聚餐了，然而我没去。（似乎年复一年都是在那里聚餐） 一班和十班是唯二的出了两个人的班级 待更人篇中年人周存盛（老周）高一班主任，物理教师，非常随和帅气的存在，生于1966.2.24。对我们的管理比较粗放——基本上只要我们不把房顶掀了，就不会责骂我们。我们十班与隔壁李丽老师噤若寒蝉的十一班形成了鲜明的对比。老周时常给我们讲他高中时候大清早翻墙出去锻炼的故事，以此来教育我们要有执行力（？？？）。 江佳兴和陆明遥一直都是令老周头疼的存在：一个时不时的消失，一个几乎不写作业。 老周可帅了 王海涛（涛哥）高二分班，九班、十班、十一班被拆掉，成立新九班和新十班作为文科班，原九、十、十一班理科同学被再分配到了一至八班。我被分配到了一班，于是成为了涛哥治下的一员。 涛哥是个非常优秀的班主任，在我们成长的过程中起到了重要的作用。我认为用我的语言来表现他的优秀是不可能也不合适的。涛哥是我求学10多年以来所见过的最好的老师，符合我心目中对一个优秀班主任的所有要求。他在与同学搞好关系上下足了精力，大部分同学也很喜欢涛哥，尽管如此，涛哥依旧会在应该严厉的时候对我们毫不留情。他对我的社团工作以及竞赛活动给予了充分理解，从来没有难为过我，并给予了我方便的条件。涛哥提出并组织了一些经典活动，这些活动大部分都延续到了高三毕业。例如全班一起给每个同学过生日，每周的说天下活动等等，这些活动让我感到充分地融入到了一班中去，这是我在老十班所得不到的感受。涛哥经常喜欢给我们讲一些心灵鸡汤，当然我所说的不是那种贬义的心灵鸡汤。这些往往都是涛哥的一些人生经验，有时则是涛哥的一些率性的真心话。涛哥的一些经典语录： 小考本拿出来 用差量法不超过三步 不要放松对自己的要求 第二次更新已经是毕业一年之后了，大部分语录都记不清了，请还记得的朋友在评论区进行评论（评论区使用disquz，需要翻墙才能看到），或者直接qq或是发邮件给我。 田长岩（老田）老田是自从我们高二开始，负责我们这届学生的社团工作。老田个子不够高，给我的印象就是萌萌哒！尤其是一次放学后，一些男教工在操场上踢球，老田发球扔球的样子！真是太可爱了。老田的正式职业是英语教师，没有上过老田的英语课真是太遗憾了！ 老田美照 待更所有之后很抱歉把这玩意写成了一个大杂烩。 因为一些原因，获得了2018年5月26日和2018年6月2日两个周末回大连的机会，我在6月2日溜进了学校，找了找当年在学校里生活的感觉。上几张图吧！ 6月2日离开学校时在解放路铁栏杆旁留下的照片图书馆东门，从来没开过藏在树后的食堂从某个角度看报告厅","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"维护新闻主机","date":"2018-07-12T06:21:08.000Z","path":"2018/07/12/维护新闻主机/","text":"考完试闲的发慌写点博客 昨天小迪篇Poeroz昨天帮房小迪trouble shoot了一下github pages的问题，傻叉github不知为何将hexo生成的静态页面给当成Jekyll源码处理了，导致一直build失败，repo中的内容无法同步到pages上，最后的解决方法是在repo里添加了一个.nojekyll文件，来强制关闭Jekyll编译功能。 凌晨大爷篇Humveea6晚上帮凌晨大爷安装了wordpress。不得不说，自己瞎搞的能力是一点没生疏，精准瞎搞的能力倒是生疏了。幸亏乱搞之前打了个snapshot，否则重头配主机岂不是很麻烦。在重置凌晨主机之后，我先把shadowsocks给安上了，用的是python版。然后apt装apache2，apt装mysql-server，然后加用户，加db，关root权限。之后不知道我脑子出了什么问题，想要编译安装php。以前装php都是apt装，没有编译安装php的相关经验，照着网上的文档瞎几把configure一发，然后就开始make。……然后……no make file？哦哦，参数写错了，我眼瞎。然后make &amp;&amp; make install，安装完之后照例要来一发phpinfo();的，然后。我，本应该写123&lt;?phpphpinfo();?&gt; 的，然而，我却写成了123&lt;?phpinfo();?&gt; 并且没有意识到这个问题。当我看到php没有被解析的时候，怀疑自己安装出现了问题。文档里面给了个–with-apxs2参数，configure的时候我没有加，我也不知道apxs是干啥的，于是尝试加这个参数重新configure。系统提示我没有apxs，谷之，装了php-dev，configure，make，make install。重新安装成功之后再次测试。这下可好，apache2直接fail to start。不想trouble shoot了，直接从snapshot重置。从shadowsocks配置完成那一步开始重新做。这次全部apt，phpinfo()依旧失败，发现了问题，改之，php工作正常。下载wordpress源码，看文档，要求php7.2+，之前Canonical的apt源提供的php版本是7.0，因此装的也是php7.0。为了升级php，我添加了ondrej/php源。update，apt install php7.2，upgrade，purge php7.0。到此，AMP配置大功告成。接下来的工作就顺畅许多，wget源码，unzip，改config，邀请凌晨install。唯一剩下两个问题，一个是语言需要切换到中文，另一个是目前控制面板中无法直接在线下载新组件或者升级。 解决 下载了中文版源码进行替换 在wp-config.php中用define(&#39;FS_METHOD&#39;, &#39;direct&#39;);选择直接写入模式，bypass掉了ftp弹窗。然后在apache2.conf里打开了目录的写权限，并在文件系统中打开了网站目录的写权限至此，整个凌晨洗澡站就搞好了。刷牙上床睡觉Zzz 今天昨晚在搞凌晨洗澡站时想去我的主机上看下我之前shadowsocks自启动配置时咋写的，顺手搞了发apt。apt提示有未满足的包依赖关系，这些出问题的包全是4.4的内核包。我尝试忽略这个问题，然而apt无法正常工作，看来这个问题必须被解决。apt让我-f install一波。我顺从的来了一发。提示no disk space，然而我看到搬瓦工控制面板上的磁盘余量是4个多GB。df查了一下，是/boot分区满了。然后我uname -r查了一下当前的内核版本：当前的版本是4.12。也就是说这些版本较旧的内核占用光了/boot分区。我只需要想办法删除这些过时的内核就可以了。卸载内核是危险的，可能会导致我的主机再也无法启动。于是我打了个snapshot。打完备份后，开始卸载内核，尝试apt remove和apt purge，失败。继续上网查解决方案，不外乎都是用apt来卸载。尝试修改了下搜索关键词，找到一个令人满意的答案。这个方案中提到了使用dpkg --force-all -P命令来强制卸载包。我直接删除了除4.12之外的所有内核包，然后update-grub。重启，重连，连接成功！也就是说内核没删错。接着df，/boot分区占用率38%，apt也可以正常使用了。然后我进行了一些常规操作12345apt autocleanapt autoremoveapt updateapt -f installapt upgrade 检修了一下webhook和webot服务，至此新闻主机的维护工作就结束了。由于一直用hexo，所以新闻主机上只有apache2，没有m和p。这次熟练的部署了m和p。","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"xxx","date":"2017-10-13T15:30:13.000Z","path":"2017/10/13/xxx/","text":"看了一篇又一篇与自己同届的朋友们写的文章，讲自己与二十四的故事，我的心里有些难受。一是我确实想念我的母校了，二是我的文字从来都是如此的无力。我从来都没有过那样一段文字，能够传达出我所想的、我所念的。我在表达上是有些问题的，枯燥如清水却漏洞百出的语言仅仅只能让对方知道我在想什么，而不能打动对方。这也是我从小到大都不喜欢写作文的原因。虽然曾有过一段记录生活的经历，但那段时间的成果也只是几页的流水记录罢了。然而对于一生挚爱来讲，她是值得我逼着自己写一点东西的，即使涛哥不布置暑假作业，我也迟早会为她写点什么的。 二十四中对我来说，是 一座校园 ＋ 一段生活 ＋ 一群旅伴 ，少了其中的任何一部分都会让她黯然失色。从踏入校园的第一天起，到卷起铺盖走出大门的最后一天，她在不断的变化，像是在伴着我们一同成长。我们看着她有了新的操场、有了新的鱼塘，教室换了新门、报告厅翻修一新，社团介绍贴满了大堂，教学楼着了新装……我记得从开始到最后，她的每个模样。高三的时候，我试图去探索校园里我所没有见过的每个角落，于是我见到了水杉林石碑后的神秘铁门、主楼地下四通八达的楼梯与走廊以及报告厅外墙大屏幕脏乱的设备室。上过了钟楼，进过了地下车库……我想她的秘密应该被我窥探的差不多了吧。 喜欢她是一种生活方式。我喜欢在出远门的时候把校徽放进背囊。我喜欢在每次路过她的时候用相机留下她的芳颜。我喜欢使用那个红色的情侣头像。我喜欢从西门慢慢走到图书馆，也喜欢旋转着从楼梯上跳下。喜欢晚上在操场上仰望月亮，也喜欢在和她告别时偷偷数着是几楼的灯还在亮着。夜晚五楼的一排灯，是为竞赛小组而亮起的。报告厅里的面灯、程控灯、追光灯，是为忙碌了日日夜夜的全体演员、全体工作组而亮起的。六楼东侧的小房间的灯，是为卓越策划日夜苦赶deadline的童工而亮起的。老教学楼的大功率照明灯，是为每一位即将离开她的人而亮起的。当所有的灯都准时地在八点钟亮起时，我和她的故事也即将画上句号。我喜欢我的旅伴。我记得每一位老师、每一位同学、每一位挚友。有了你们，绿树红墙在我眼中才能如此的鲜艳。尽管各奔四方，但我们都同样的爱着她。 在北邮已经呆了将近两个月了，高中三年所期待的大学生活也仅此而已，来到这不是最理想的选择，却也是个能令我满意的选择。生活和学习的忙忙碌碌让我决定做一个小透明，在将她埋在心底的同时继续向前。 [等待修改和增加] 仔细想想我还是不想把它发给涛哥","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"新主机到货!","date":"2017-07-02T07:38:37.000Z","path":"2017/07/02/新主机到货/","text":"surface book 增强版 512G用了学生优惠。 散热不太好，或者说发热比较大？但由于SB的主要发热元件全部都在屏幕上，掌托比较凉爽，所以影响不是很大。当然要是发热的时候用SB进行书写不是什么明智的决定：烫死你！ 还买了一个Dock和一个笔尖工具包，H的笔头用起来最舒服。","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"升级了hexo","date":"2017-02-26T03:53:35.000Z","path":"2017/02/26/升级了hexo/","text":"很久没动hexo了，今天把hexo和indigo都给升级了。hexo-generator-feed不支持hexo 3.2，给我造成了很大的麻烦。不过新indigo很漂亮，之前用的indigo是我提交pr补搜索bug前的那一版。后天召集全天，GG","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"一些旧图","date":"2016-11-15T15:18:22.000Z","path":"2016/11/15/一些旧图/","text":"这周五好像是本学期第一节社团课，不过已经跟我没什么关系了。跟我有些关系的是周五的成人仪式。今天要收打算放在时间胶囊里的小物件。我写了一张嘲讽两百天之后的我的字条。awkward. 贴几张图吧。 去年社团课的摆拍，年册照片（本指望把第二张做到年册上去，愿望落空） 去年高三的成人仪式总控由我负责我明明搞砸了它我搞砸过不少事情 我超爱的合影板，应该还在这张照片是高一下半学期照的 走到头就开始喜欢回忆了。我真完蛋。","tags":[]},{"title":"三家公司和两款洗衣机","date":"2016-09-11T13:42:49.000Z","path":"2016/09/11/三家公司和两款洗衣机/","text":"B厂设计生产了一款洗衣机O，为了小钱钱，B厂将洗衣机O送入了他开在中国大陆的工厂直营店BattleShop。由于洗衣机质量好，且B厂宣传到位，新款洗衣机大卖，收获消费者的一致好评。 另一家公司，HR厂此前设计生产过许多质量上乘的家用电器。可HR厂并不善于做买卖，以至于并没有许多客户来购买他的电器。 还有一个百货超市Tmart，他的故事就比较长了。 Tmart超市中有很多家用电器，不过他的营销方式不同于B厂。Tmart喜欢搞中国特色的“零元购”。消费者可以免费获得基本款的电器，Tmart会给那些愿意付费的用户加装更多的外设，让电器拥有更加强大的功能。 一些零消费用户和一些低消费用户看到邻居家中的高档电器之后，心生怨恨，大骂Tmart无良，坑钱，嘴里还嘟嘟囔囔：“你们店里的电器这么垃圾，我用你们的电器是给你们面子！”当然这些阿Q多半是不舍得在Tmart的电器上花钱的。 也有一些吃瓜群众来到Tmart之后，对着店里的电器指指点点。“你看那个电冰箱CreepyFrost哟，和那个TCBuy的电冰箱长的好像啊。你看你看，TCBuy的电冰箱有两个门，它也有两个门。TCBuy的电冰箱是长方体的，这个电冰箱也是长方体的。就连这电冰箱的制冷功能也和TCBuy的那款CStorm一模一样。Tmart真是太不要脸了，对知识产权毫无敬畏之心。”当然，他们并不知道他们所说的那两款电冰箱是分别由SlimeGay和VN 工厂生产的，电冰箱在他们眼中也都是一样的。 话归正题。之前说到HR厂虽然有好电器，却一直卖不出去。HR厂的新电器洗衣机P的生产线最近刚刚落成，急于拓展市场的他在中国并没有直营店。于是HR厂决定找一家百货超市合作。经过周密的调研，HR厂锁定了电器贩卖经验丰富，客户众多，效益极佳的Tmart。Tmart也认为洗衣机P是一款优秀的洗衣机，上架它一定能够提高Tmart的业绩。于是两家一拍即合，决定于9月13日将洗衣机上架到Tmart试卖。于是淳朴的吃瓜群众再次捧着西瓜，拿着Tmart的广告单，开始侃起了大山。 “你看，Tmart终于还是下手了，他们也做了一台可以洗衣服的机器。”“是啊是啊，他们只会模仿和抄袭。你看，那滚筒，那玻璃门，那开关，那塑料外壳，哪个不是B厂洗衣机O上有的东西？就连那洗衣服的功能也是模仿B厂洗衣机O的。”当然，他们应该不知道第一个实现洗衣服功能的其实是搓衣板TF，他们也依然搞不清百货超市和电器工厂的区别。Tmart所属的T集团自己也生产电器，T集团的几乎每一款产品都有人说诸如此类的闲话。“T的主打产品摩托车Q是抄袭了儿童三轮车OQ才有T集团今天的成绩的！”“T的电动麻将桌是抄袭了LZ的扑克桌，垃圾！”“T只会抄袭，他们是靠抄袭才发家的，无耻！”…… 我不求那些吃瓜群众有购买脑白金的自觉，也不会建议身边的此类吃瓜群众去买脑白金。毕竟Tmart的电器大都比那些他们口中被抄袭的产品好用得多，我用的很开心呢。 有意提高姿势水平的朋友，我给你们个链接：aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzE5NzgzMjg5L2Fuc3dlci8xOTc0NDg1MA==随便找个BASE64工具Decode一下就好了","tags":[{"name":"文","slug":"文","permalink":"http://cjsoft.github.io/tags/文/"}]},{"title":"开学啦","date":"2016-08-31T09:35:42.000Z","path":"2016/08/31/开学啦/","text":"高三啦，滚回文化课两年OI一场空，最后还是见祖宗明明过去没有多长时间，却好像是很久之前的事情一样。学了那么多算法、数据结构，最后还是打了五道暴力。脑袋里全部都是方的，hash、tarjan啥的都没打出来。去查分的时候腿是软的，出来的时候还是软的。作为D类选手拿了屁用没有的铜牌，什么学校都签不到。 回到学校，见了两个多月没有见过的同学，多少有些生疏。有的人的名字甚至需要我想一想才能记起来。见到了两个多月没有见过的校园。变化说不上天翻地覆，也是不小。学校的房顶被漆成了绿色，可我已经记不起来学校房顶原来的颜色了。校门口在建的新火车头体育场已经从我出发时的深坑长成了平地，甚至连观众席也搭起来了。每个教室的黑板下面都多了个奇怪的橘黄色双筒，上面接着个大管子，据说是电动黑板擦？？？ 终于轮到我们入主红楼。我们班的教室是全高三最大的一个，另一个最大的教室是二班的。教室三面都是窗，冬天应该会非常冷，夏天应该会非常热。卫生间在走廊遥远的另一头，小卖铺却很近，出了教室门，顺着楼梯向下一直走就是了。26号那天，我们几个男生过来搬东西。几乎是给老教室拆的什么也不剩，连垃圾桶都拿走了，只给新高二留了两张黑板贴。 旧教室，拿着中国结的是我 新教室 画面里其实有5个人 今年新高一军训在校内，比我们那届是享福多了。午休足、放学早，吃饭应该也没啥特别的讲究。 现在主楼里也没有几个熟悉的面孔了大概只有吃饭的时候会回主楼吧 召集那天，我先是被10班姜大佬找去给投影接线，手忙脚乱弄好之后就溜走了。然后和拓拓一起蹭窗。紧接着又被线段钩抓去了文综办公室，去调打印机共享。稀里糊涂弄完之后回到教室，发现大清扫已经搞完了。老师讲了几件事就把我们给放了。我和拓拓回主楼拿柜子里的东西，本想直接从北门出去，结果发现北门现在不让走，因为体育场施工危险。不得已，我从西门出去，绕了一圈，走的还是北门那条路。 31号是开学典礼，依旧是在舰艇学院，解放路东段依旧堵的很厉害。学校请了校友陈年，他的讲话挺有意思的，大家听得挺开心的，就是政治不正确（学校的政治）。以后到舰艇学院的机会应该不超过两次了，运动会一次，元旦一次（够呛能有）。中午是班级聚会，人没来齐，没啥意思。 不太一样的高三、开始了。","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"NOI2016之后","date":"2016-08-01T02:42:22.000Z","path":"2016/08/01/NOI2016之后/","text":"NOI2016考了个尴尬的分数，现在正式AFO了。这破博客回头慢慢zhou理，说不定以后会写回忆录啥的。不过我好懒啊，估计得几年之后了 你好呀房庆凯","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"日常","slug":"日常","permalink":"http://cjsoft.github.io/tags/日常/"}]},{"title":"Link Cut Tree的板子","date":"2016-05-30T12:52:36.000Z","path":"2016/05/30/Link-Cut-TREE/","text":"第一回写lct，问阿凡和线段钩把关键地方弄懂之后就很好写了，为了兼容我的splay风格，我看了至少三个风格完全不同的人的讲稿。其中po姐ZigZag分开写的，不能忍。ACDreamer是用tag来标记isroot，不懂。还有就是毛爷爷的版本，和我的风格最为接近。于是综合几个版本一起看了看，把毛爷爷的板子改了改就和我的风格完全兼容了。 讲道理，lct使用splay维护多棵辅助树来实现那么多玄学的功能。 大概有一下几种操作： expose(x)，使x到原树树根的所有边串成一个prefered path，到根的路径的所有点都在同一棵splay上，同时断开x与原来prefered child的联系。 makeroot(x)，使x成为所在原树的根，具体实现方法是expose(x); splay(x); reverse(x);。 link(u, v)，在给出的u, v保证连边后原图仍为森林或树的情况下，将u, v连边，具体实现方法是makeroot(u); u-&gt;parent = v; expose(u); cut(u, v)，在给出的u, v保证原来有边的情况下，将u, v间的边断开，具体实现方法是makeroot(u); splay(v); v-&gt;leftchild-&gt;parent = nil; v-&gt;leftchild = nil; findATRoot(x)，找x所在辅助树的根，用于判断联通性，具体实现方法是不断的向上找parent，直到当前节点没有parent，则当前节点是辅助树的根。 findroot(x)，找x所在原树的根，具体实现方法是先expose(x)，然后不断找x在splay上的左儿子，直到左儿子为nil，最后splay一下当前节点，当前节点为x所在原树的根。 注意所有往儿子找信息的时候都要pushdown 然后照例https://github.com/cjsoft/noip/tree/master/after_lnoi/d0530其中lct.copy.cpp是比较规范的板，lct.cpp不是太工整","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"动态树","slug":"动态树","permalink":"http://cjsoft.github.io/tags/动态树/"},{"name":"数据结构","slug":"数据结构","permalink":"http://cjsoft.github.io/tags/数据结构/"},{"name":"树","slug":"树","permalink":"http://cjsoft.github.io/tags/树/"}]},{"title":"BZOJ1500维修数列","date":"2016-05-29T07:13:12.000Z","path":"2016/05/29/BZOJ1500维修数列/","text":"这个是货真价实的板题、唯一值得提一嘴的是求和最大的子列需要至少有一个元素，一开始理解错了，以为可以长度为0，然后就GG了一晚上加半个头午。还有这道题只有64M要写个简单的内存管理。用了线段树风格的build和读入优化后能把时间减少一半左右。照例https://github.com/cjsoft/noip/tree/master/after_lnoi/d0528","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"平衡树","slug":"平衡树","permalink":"http://cjsoft.github.io/tags/平衡树/"},{"name":"数据结构","slug":"数据结构","permalink":"http://cjsoft.github.io/tags/数据结构/"}]},{"title":"BZOJ1014火星人prefix","date":"2016-05-29T06:53:48.000Z","path":"2016/05/29/BZOJ1014火星人prefix/","text":"可以算是平衡树的半个版题吧。做法是维护节点表示字符串的hash，询问的时候二分长度。可以维护hash是因为BKDR-HASH的计算方法是$$BKDR(s)=\\sum_{i=1}^{n}S_ip^{n-i}$$向上合并的时候左面儿子的hash乘上$p^{k+1}$，加上节点权值乘上$p^{k}$，加上右儿子的hash即为此节点的hash值，其中$k$为右儿子大小。这道题做的时候我把字符串直接串成一个长链，接到平衡树上面（以前都是这么写的），虽然很low但是能过。然后后来我发现了网上大家都是像线段树那么构建的，我好方。so sad时间复杂度$O(n \\log^2 n)$照例https://github.com/cjsoft/noip/tree/master/after_lnoi/d0527这两天效率好低","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"hash","slug":"hash","permalink":"http://cjsoft.github.io/tags/hash/"},{"name":"字符串","slug":"字符串","permalink":"http://cjsoft.github.io/tags/字符串/"},{"name":"平衡树","slug":"平衡树","permalink":"http://cjsoft.github.io/tags/平衡树/"},{"name":"数据结构","slug":"数据结构","permalink":"http://cjsoft.github.io/tags/数据结构/"}]},{"title":"AC自动机的那一套理论","date":"2016-05-26T11:59:17.000Z","path":"2016/05/26/AC自动机的那一套理论/","text":"这坑我暂时不想填我的某一个repo里面似乎有我的板子","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"字符串","slug":"字符串","permalink":"http://cjsoft.github.io/tags/字符串/"},{"name":"数据结构","slug":"数据结构","permalink":"http://cjsoft.github.io/tags/数据结构/"}]},{"title":"后缀自动机的那一套理论","date":"2016-05-26T11:59:08.000Z","path":"2016/05/26/后缀自动机的那一套理论/","text":"这坑我暂时不想填我的某一个repo里面似乎有我的板子","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"字符串","slug":"字符串","permalink":"http://cjsoft.github.io/tags/字符串/"},{"name":"数据结构","slug":"数据结构","permalink":"http://cjsoft.github.io/tags/数据结构/"}]},{"title":"单调队列dp","date":"2016-05-20T14:26:00.000Z","path":"2016/05/20/单调队列dp/","text":"单调队列优化是利用状态转移时的单调性来对dp进行优化的一种做法，类似于斜率优化。不同之处在于单调队列是将dp转移方程分解成$f(i) + g(j)$两部分，其中$f(i)$只与$i, j$中的$i$有关，$g(j)$只与$i, j$中的$j$有关。我们看他如何在朴素dp是二维的情况下将复杂度降一个维度：从$1 \\ldots n$扫描，每到一个状态i，我们看$f(i - 1)$是否比队列尾更优，如果更优，从队尾循环弹出元素，直到$f(i)$不比队尾状态的$f$值更优，将其压入，并用队首元素更新$dp_i$。 似乎这个单调队列有时候可以只用一个变量来保存最值就好了，不过我做过的题少，我不知道我这个看法对不对。不过UESTC上594题“我要长高”是可以这样做的。 下面提供UESTC 594的代码https://github.com/cjsoft/noip/tree/master/after_lnoi/d0520其中cdoj594.cpp是我照网络上的代码写出来的cdoj594.copy.cpp是我徒手又写了一遍anothercopy.cpp是使用一个变量+滚动数组写的","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"动态规划","slug":"动态规划","permalink":"http://cjsoft.github.io/tags/动态规划/"},{"name":"算法","slug":"算法","permalink":"http://cjsoft.github.io/tags/算法/"}]},{"title":"斜率优化dp","date":"2016-05-18T13:02:47.000Z","path":"2016/05/18/斜率优化dp/","text":"LNWC上其实讲过斜率优化，但是那阵子颓的不行，都没听懂。今天学习了一下DP的斜率优化。斜率优化通常用来优化具有一下性质的DP问题： 将一段序列划分为多段连续区间 DP方程中有形如$A_iB_j$的项。（例如$S_iS_j$） 设从状态$j$转移到状态$i$时$Dp_i = f(j)$，最佳方案取最小值（最大值同理），有$k \\leq j \\leq i$，若向状态$i$转移，$j$不比$k$差，则有$f(j) \\leq f(k)$，移项，有形如$\\frac{y_j - y_k}{x_j - x_k} \\leq A_i$的不等式，这是$j$不比$k$差的必要条件。 我们再设$g(p, q) = \\frac{y_p - y_q}{x_p - x_q}$，若$g(i, j) \\leq g(j, k)$，我们可以直接丢掉状态$j$，原因如下： 若$g(i, j) \\leq A_i$，则$i$不比$j$差。若$g(i, j) &gt; A_i$，可知$g(j, k) &gt; A_i$，$k$也不比$j$差由此可见，若$g(i, j) \\leq g(j, k)$，状态$j$永远不会成为更优的状态，所以可以直接丢掉 需要证明的东西只有以上内容，下面简述一下流程。首先我们搞一个双端队列来维护一个状态序列，这个序列当中，每三个位置元素$a, b, c$，都保证$g(c, b) &gt; g(b, a)$。 将第一个状态的DP转移来源压入队列。从$1 \\ldots n$循环扫描（不一定从$1$开始），做如下四步： 当队列中队首往后的一个状态不比队首状态差时，弹出队首元素，直到队首状态比其后第一个状态更优为止。 用队首状态去更新当前状态。 考虑当前状态$i$，设队尾状态为$j$，队尾前一个状态为$k$，当$g(i, j) \\leq g(j, k)$时，弹出队尾状态，直到$g(i, j) &gt; g(j, k)$为止。 将当前状态压入队尾 个人感觉如果确定这道题可以用斜率优化DP，那么剩下的就是套路了，先推$g(p, q)$，然后按照流程来就可以了 代码如下https://github.com/cjsoft/noip/tree/master/after_lnoi/d0518hdu2507.copy.cpp是自己徒手重写的hdu2829.cpp是自己推外加参考资料写出来的","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"动态规划","slug":"动态规划","permalink":"http://cjsoft.github.io/tags/动态规划/"},{"name":"算法","slug":"算法","permalink":"http://cjsoft.github.io/tags/算法/"}]},{"title":"lps最长回文子串","date":"2016-05-18T03:23:03.000Z","path":"2016/05/18/lps最长回文子串/","text":"得到串a后，拼接出如下串a#rev(a)，求出他们的rank和height数组。然后我们对$0\\ldots l1-1$扫描，此时需要分两类： 长度为奇数的回文串 长度为偶数的回文串 对于情况①，我们要求以$S_i$为中心的最长回文串（设长度为k），我们求$T_{i + 1}$与$T_{l * 2 - i}$的最长公共前缀，容易发现这个最长公共前缀是由$S_i$与$\\lfloor \\frac{k}{2}\\rfloor$长度的回文串的右部分拼接成的，所以此位置情况①的最长回文子串的长度k为$T_i$与$T_{l \\times 2 - i}$的最长公共前缀长度×2-1，可用height求 对于情况②，与情况①不同的地方在于$T_i$与$T_{l * 2 - i}$的公共前缀长度正好是以此为中心左侧位置的最长回文子串的长度÷2 我们可以根据中心位置m和最长回文子串的长度来推知起始位置和结束位置，以此为依据输出最长回文子串。 此算法复杂度为$O(n \\log n)$ 代码见https://github.com/cjsoft/noip/tree/master/after_lnoi/d0517其中leetlps.cpp是leetcode上的交互版lps.cpp是普通版","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://cjsoft.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://cjsoft.github.io/tags/算法/"}]},{"title":"智障数组","date":"2016-05-17T02:10:38.000Z","path":"2016/05/17/智障数组/","text":"mdzz，get_height总是越界，试图访问sa -1的位置，看了之前写的AC代码，发现getsa传入的字符串长度比正常的字符串长度长1。最后想半天，想起来是为了使有效的sa从sa[1]开始，所以我们在字符串后面插入一个比所有元素都要小的元素0。 mdzz药丸","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"朝圣之旅","date":"2016-05-07T15:59:59.000Z","path":"2016/05/07/朝圣之旅/","text":"本文作者为莱士传媒旗下记者杜皿煮 事情是这样的。我们几个同学在北京比赛，难得有一晚空闲，作为资深膜法师，决定去一趟梦寐以求的华莱士餐厅朝圣。通过某同学的魅族手机自带的地图（服务提供商为高德），我们找到了一家在地图上看来位于北京市中心的华莱士餐厅。打电话给这家餐厅，说八点半就打烊了。看一眼表已经七点半了，我们决定立即出发。不过燕郊这名听着不大对？然而我们几个人对北京不甚熟悉，也就没在意。上了出租车，司机说他不知道这家店，不过看地图在王府井附近，就拉着我们往那边走了，这个时候他念叨了一句“燕郊不在北京啊”，然而我们都没在意。开到王府井附近，对面的各种机关大院，导航突然指引我们往院里开。看着门口的武警，我们显然没有进去，选择了下车步行寻找。绕着大院走了半圈，走到了地图上这条道路的另一个方向，我们惊喜地发现……还是有武警把门。我这时候感觉事情不对，搜了一下燕郊，才发现燕郊在廊坊。同学这时候看了眼通话记录，才注意到……刚刚他拨打的电话，归属地也是河北廊坊。抱着既来之则安之的心态，我们虽然内心有无数草泥马跑过，却也还是去附近的天安门拍了两张照，又去王府井吃了顿饭，然后打车往回走。在路上我越想事情越不对，干脆拿出手机，看了下手机其他地图软件，附近的商户情况。百度、腾讯和Here表现很正常，附近没有任何商户。快的打车的地图上面……也有一个华莱士餐厅（燕郊店），但附近其他商户却和高德不一样。我的手机是WP系统没有快的打车，我也不知道快的的地图提供商，但是我使用网页版高德地图截取了附近部分错误商户的信息，如下图所示。 首先是这个明显不对的华莱士。 附近距离不远的汽修店，位于“东城区”西红门桥。 位于“东城区”十里河的核桃店。 位于“东城区”五道口的蛋糕店。……还有很多。 现在主要的疑问有两个。①为什么在东交民巷旁边，这个有大量政府机关的地方，会有这么多错误的商户信息？②为什么快的打车和高德地图的错误商户并不相同，却都有一家位于廊坊的华莱士餐厅被定位于此处？","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"fav.AStarSearching","date":"2016-05-04T02:51:27.000Z","path":"2016/05/04/fav-AStarSearching/","text":"http://blog.jobbole.com/71044/http://blog.csdn.net/v_JULY_v/article/details/6093380","tags":[{"name":"fav","slug":"fav","permalink":"http://cjsoft.github.io/tags/fav/"}]},{"title":"简单的主席树","date":"2016-05-03T07:22:35.000Z","path":"2016/05/03/简单的主席树/","text":"这个东西几天前就整完了，今天整理一下思路。 首先这里讨论的是可持久化权值线段树。可持久化的普通线段树我不会写，但是我猜思想应该是相同的。通过将新版本上没有修改的节点接回上一个版本来实现最大限度的重用数据。 区间第k大用可持久化权值线段树的做法如下： 将n个值按照顺序逐个插入树中，产生n个历史版本 对于查询区间[l, r]的第k大值，我们用第r个版本与第l-1个版本的树相减，得到一棵新的树（实际上我们并不需要构造新的树，只需要同时接受两个节点指针，向下查询时算出相减后的节点信息即可），求这棵树上的全区间第k大即为答案 POJ 2104 Solution 可持久化数据结构的坑应该很大，目前我只看到了一点皮毛，有待更深的研究","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://cjsoft.github.io/tags/数据结构/"},{"name":"树","slug":"树","permalink":"http://cjsoft.github.io/tags/树/"}]},{"title":"最长公共字串","date":"2016-05-03T06:29:50.000Z","path":"2016/05/03/最长公共字串/","text":"两个字符串间的最长连续公共子串是后缀数组能解决的经典问题之一。其方法为将两个子串连接，中间用一个没有出现过的字符间隔，之后求这个新字符串的SA数组和height数组，对于每个有效的height值，我们判断它对应的两个后缀的开始位置是否属于两个不同的初始串，是的话，用这个height来更新结果。证明略（这个想一下就明白了啊） 从此以后，我将不会在正文中贴代码，因为这样配合indigo的主题很丑，我将会贴出代码的链接 CodeVS 2160 Solution","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"序列","slug":"序列","permalink":"http://cjsoft.github.io/tags/序列/"},{"name":"算法","slug":"算法","permalink":"http://cjsoft.github.io/tags/算法/"}]},{"title":"fav.后缀数组","date":"2016-05-03T02:58:42.000Z","path":"2016/05/03/fav-后缀数组/","text":"http://www.cnblogs.com/staginner/archive/2012/02/02/2335600.html","tags":[{"name":"fav","slug":"fav","permalink":"http://cjsoft.github.io/tags/fav/"}]},{"title":"后缀数组","date":"2016-05-03T02:28:57.000Z","path":"2016/05/03/后缀数组/","text":"我感觉我彻底理解后缀数组是无望了。不过只要牢记几个定义，背板就不是那么难了。 sa[i] 表示所有后缀排序后排在第i个的后缀的起始位置是几。 rank[i] 是sa[i]的逆映射 板子里的x[i]在最后swap之前表示的是起始位置为i，长度为j的串的rank是几 y[i] 表示的是第二关键字的temp sa[i]，也可以看做是除去了源串前j字符的剩余串中长度为j的子串排序结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MXN 100007using namespace std;char s[MXN];int sequence[MXN];int sa[MXN], h[MXN];int t1[MXN], t2[MXN], c[MXN], rank[MXN];void getsa(int raw[], int sa[], int n, int m) &#123; int *x = t1, *y = t2; for (int i = 0; i &lt; m; ++i) c[i] = 0; for (int i = 0; i &lt; n; ++i) ++c[x[i] = raw[i]]; for (int i = 1; i &lt; m; ++i) c[i] += c[i - 1]; for (int i = n - 1; i &gt;= 0; --i) sa[--c[x[i]]] = i; for (int j = 1, p = 0, i = 0; j &lt;= n &amp;&amp; p &lt; n - 1; j &lt;&lt;= 1, m = p + 1, p = 0) &#123; for (i = n - j; i &lt; n; ++i) y[p++] = i; for (i = 0; i &lt; n; ++i) if (sa[i] &gt;= j) y[p++] = sa[i] - j; for (i = 0; i &lt; m; ++i) c[i] = 0; for (i = 0; i &lt; n; ++i) ++c[x[y[i]]]; for (i = 1; i &lt; m; ++i) c[i] += c[i - 1]; for (i = n - 1; i &gt;= 0; --i) sa[--c[x[y[i]]]] = y[i]; for (i = 1, std::swap(x, y), p = 0, x[sa[0]] = 0; i &lt; n; ++i) x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + j] == y[sa[i - 1] + j]) ? p : ++p; &#125;&#125;void getheight(int raw[], int sa[], int h[], int n) &#123; int i, j, k; for (i = 1; i &lt;= n; ++i) rank[sa[i]] = i; for (k = 0, i = 0; i &lt; n; h[rank[i++]] = k) for (j = sa[rank[i] - 1], k ? --k : 0; raw[i + k] == raw[j + k]; ++k);&#125;int main() &#123; int l; scanf(\"%d\", &amp;l); scanf(\"%s\", s); for (int i = 0; i &lt; l; ++i) &#123; sequence[i] = s[i] + 1; &#125; getsa(sequence, sa, l + 1, 257); // getheight(sequence, sa, h, l); for (int i = 1; i &lt;= l; ++i) &#123; printf(\"%d\\n\", sa[i] + 1); &#125; return 0;&#125; 值得注意的是，大循环的上一行的循环和包含std::swap(x, y)的行的上一行的循环是逆序的，原因是为了保证当串相同的时候，位置靠前的串排序后能够更加靠前。","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://cjsoft.github.io/tags/数据结构/"},{"name":"树","slug":"树","permalink":"http://cjsoft.github.io/tags/树/"},{"name":"算法","slug":"算法","permalink":"http://cjsoft.github.io/tags/算法/"}]},{"title":"24OI文化衫","date":"2016-05-02T08:22:38.000Z","path":"2016/05/02/24OI文化衫/","text":"准备订文化衫啦。仪式的成分更多一些呢。为了统计尺码，我重新部署了以前自己写的Ez InfoCollector，竟然还可以用。因为是私下里收集信息，所以不贴演示界面了。项目我同时托管在了我的github和coding上，欢迎fork","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"矩形面积并","date":"2016-05-02T00:27:02.000Z","path":"2016/05/02/矩形面积并/","text":"得从大上个po开始说。我不是根据矩形周长的AC代码了解了扫描线的思想么，然后我就开始根据矩形并周长的做法来yy矩形面积并的做法。事实上，我第一次yy出来的代码已经是正确的能够AC的了，然而因为http://wallacenews.tk/2016/05/01/囧/上所提到的原因，我没有AC。于是yy的代码被窝删掉了。然后我又照着AC的代码撸半天结果WA，好，最后发现是poj的锅。^&amp;%&amp;&amp;*&amp;GUGUT756rygu日了狗了！今天早上重新写了昨天自己yy的方法，提交，AC，日狗 贴yy的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define lson(x) (x &lt;&lt; 1)#define rson(x) (x &lt;&lt; 1 | 1)#define mid(l, r) ((l + r) &gt;&gt; 1)#define MXN 207using namespace std;struct seg &#123; double x1, x2; int atag; double y; int lx1, lx2; seg() &#123;x1 = x2 = y = atag = 0;&#125; seg(double a, double b, double c, int d):x1(a),x2(b),y(c),atag(d) &#123;&#125; bool operator&lt;(const seg &amp;b) const &#123; return y == b.y ? atag &gt; b.atag : y &lt; b.y; &#125;&#125; ss[MXN];int cnt[MXN &lt;&lt; 2 | 7];int ll[MXN &lt;&lt; 2 | 7], rr[MXN &lt;&lt; 2 | 7];double stree[MXN &lt;&lt; 2 | 7];double prefix[MXN], loc[MXN];inline void pushup(int root, int l, int r) &#123; if (cnt[root]) &#123; stree[root] = loc[r] - loc[l - 1]; &#125; else if (l == r) &#123; stree[root] = 0; &#125; else &#123; stree[root] = stree[lson(root)] + stree[rson(root)]; &#125;&#125;void adddata(int root, int l, int r, int al, int ar, int data) &#123; if (l &gt; ar || r &lt; al) return; if (l &gt;= al &amp;&amp; r &lt;= ar) &#123; cnt[root] += data; pushup(root, l, r); return; &#125; adddata(lson(root), l, mid(l, r), al, ar, data); adddata(rson(root), mid(l, r) + 1, r, al, ar, data); pushup(root, l, r);&#125;int main() &#123; int n = 0; int t = 1; while (~scanf(\"%d\", &amp;n)) &#123; if (n == 0) return 0; double a, b, c, d; int m = 0, cur = 0; for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%lf %lf %lf %lf\", &amp;a, &amp;b, &amp;c, &amp;d); ss[m++] = seg(a, c, b, 1); ss[m++] = seg(a, c, d, -1); loc[cur++] = a; loc[cur++] = c; &#125; sort(loc, loc + cur); int sz = unique(loc, loc + cur) - loc; for (int i = 0; i &lt; sz; ++i) &#123; prefix[i + 1] = loc[i]; &#125; for (int i = 0; i &lt; m; ++i) &#123; ss[i].lx1 = lower_bound(loc, loc + sz, ss[i].x1) - loc + 1; ss[i].lx2 = lower_bound(loc, loc + sz, ss[i].x2) - loc + 1; &#125; sort(ss, ss + m); double last = 0, resu = 0; for (int i = 0; i &lt; m; ++i) &#123; adddata(1, 1, sz, ss[i].lx1, ss[i].lx2 - 1, ss[i].atag); if (i != m - 1) resu += fabs(stree[1]) * (ss[i + 1].y - ss[i].y); last = stree[1]; &#125; printf(\"Test case #%d\\nTotal explored area: %.2lf\\n\\n\", t++, resu); &#125;&#125; 这里处理线段的方法是将离散后的右端减去1，这样一个节点[l, r]所表示的区间就是[rev(l), rev(r + 1)]，也就是说叶子节点i表示的是一个单位线段从[rev(i), rev(i + 1)]。 贴上照着别人的代码撸出来的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define lson(x) (x &lt;&lt; 1)#define rson(x) (x &lt;&lt; 1 | 1)#define mid(l, r) ((l + r) &gt;&gt; 1)#define MXN 207using namespace std;struct seg &#123; double x1, x2; int atag; double y; int lx1, lx2; seg() &#123;x1 = x2 = y = atag = 0;&#125; seg(double a, double b, double c, int d):x1(a),x2(b),y(c),atag(d) &#123;&#125; bool operator&lt;(const seg &amp;b) const &#123; return y == b.y ? atag &gt; b.atag : y &lt; b.y; &#125;&#125; ss[MXN];int cnt[MXN &lt;&lt; 2 | 7];int ll[MXN &lt;&lt; 2 | 7], rr[MXN &lt;&lt; 2 | 7];double stree[MXN &lt;&lt; 2 | 7];double prefix[MXN], loc[MXN];void build(int root, int l, int r) &#123; stree[root] = cnt[root] = 0; ll[root] = l; rr[root] = r; if (l + 1 == r) return; build(lson(root), l, mid(l, r)); build(rson(root), mid(l, r), r);&#125;inline void pushup(int root) &#123; if (cnt[root]) &#123; stree[root] = prefix[rr[root]] - prefix[ll[root]]; &#125; else if (ll[root] + 1 == rr[root]) &#123; stree[root] = 0; &#125; else &#123; stree[root] = stree[lson(root)] + stree[rson(root)]; &#125;&#125;void adddata(int root, int l, int r, int data) &#123; if (ll[root] == l &amp;&amp; rr[root] == r) &#123; cnt[root] += data; &#125; else if (r &lt;= mid(ll[root], rr[root])) &#123; adddata(lson(root), l, r, data); &#125; else if (l &gt;= mid(ll[root], rr[root])) &#123; adddata(rson(root), l, r, data); &#125; else &#123; adddata(lson(root), l, mid(ll[root], rr[root]), data); adddata(rson(root), mid(ll[root], rr[root]), r, data); &#125; pushup(root);&#125;int main() &#123; int n = 0; int t = 1; while (~scanf(\"%d\", &amp;n)) &#123; if (n == 0) return 0; double a, b, c, d; int m = 0, cur = 0; for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%lf %lf %lf %lf\", &amp;a, &amp;b, &amp;c, &amp;d); ss[m++] = seg(a, c, b, 1); ss[m++] = seg(a, c, d, -1); loc[cur++] = a; loc[cur++] = c; &#125; sort(loc, loc + cur); int sz = unique(loc, loc + cur) - loc; for (int i = 0; i &lt; sz; ++i) &#123; prefix[i + 1] = loc[i]; &#125; for (int i = 0; i &lt; m; ++i) &#123; ss[i].lx1 = lower_bound(loc, loc + sz, ss[i].x1) - loc + 1; ss[i].lx2 = lower_bound(loc, loc + sz, ss[i].x2) - loc + 1; &#125; build(1, 1, sz); sort(ss, ss + m); for (int i = 0; i &lt;= sz; ++i) &#123; &#125; double last = 0, resu = 0; for (int i = 0; i &lt; m; ++i) &#123; adddata(1, ss[i].lx1, ss[i].lx2, ss[i].atag); if (i != m - 1) resu += fabs(stree[1]) * (ss[i + 1].y - ss[i].y); last = stree[1]; &#125; printf(\"Test case #%d\\nTotal explored area: %.2lf\\n\\n\", t++, resu); &#125;&#125; 这里表示线段的方法是[l, r]表示[rev(l), rev(r)]，需要注意的是判断叶子节点的方法从l == r变成了l + 1 == r，判断是否包含区间的方式也发生了变化，为l == ll[root] &amp;&amp; r = rr[root]，除此之外每个节点的左右界最好在最开始的时候通过build的方式算出来。","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"扫描线","slug":"扫描线","permalink":"http://cjsoft.github.io/tags/扫描线/"},{"name":"数据结构","slug":"数据结构","permalink":"http://cjsoft.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://cjsoft.github.io/tags/算法/"},{"name":"线段树","slug":"线段树","permalink":"http://cjsoft.github.io/tags/线段树/"},{"name":"计算几何","slug":"计算几何","permalink":"http://cjsoft.github.io/tags/计算几何/"}]},{"title":"囧","date":"2016-05-01T14:15:04.000Z","path":"2016/05/01/囧/","text":"一开始自己yy出了一份代码，调了好久都是WA。后来照着AC代码写了一份，本地过，交上去，WA。又调了好久，后来贴了两份标程上去，WA！ mdzz！ 后来发现是poj的锅，把提交语言从g++改成c++就过了。 完全不清楚原因啊！！、 完了，一开始yy出来的代码我没stage过，根本不知道自己yy的对不对啊！！、","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"矩形并的周长","date":"2016-05-01T08:20:21.000Z","path":"2016/05/01/矩形并的周长/","text":"今年省选有道题是圆面积的异或并，是扫描线的经典问题。徐人权的大纲上有太多东西我都不会，我恰好又翻到了扫描线，于是决定研究一下扫描线。目前为止我只做了一道扫描线的题，是POJ 1177，也是IOI 98的试题，Picture，学习的还不深，在此记录一些心得。 先将平面上的元素按照一个固定的方向进行切割，把他们变成一个个按照这个方向排列的插入事件和删除事件，接着按照这个方向逐个处理事件并使用某种数据结构对当前信息进行维护，通过当前信息累计，最终求得答案。 Picture这道题的关键点倒不在于如何分割这些矩形，而是在于如何维护当前信息。就像许多网上能够查到的该题的AC代码一样，我使用了线段树来维护信息。不过AC代码中存在一个令我感到困惑的地方： 线段树涉及到了区间快速操作，却没有tag，虽然有一个cnt域，根据这个域的定义，一个节点的祖先的cnt域不应大于该节点的cnt域，但是这个cnt域既不会上推，也不会下传，显然不能满足定义。 根据我的胡乱猜测，没有tag是因为我们的查询仅仅涉及整个区间，更小的区间的cnt域正确与否对我们所需要的结果产生不了影响。除此之外，在对一个区间进行减操作之前，之前一定会对其进行至少一个加操作，使得cnt域不会出现负数。 根据脑洞，这道题至少可以用三种不同的方法进行解答。是由子方法A、B组合出来的。子方法A、B在我的提交代码中均有体现，实际上，我用的是AB组合陈宏的论文下面贴上代码及提交截图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define lson(x) (x &lt;&lt; 1)#define rson(x) (x &lt;&lt; 1 | 1)#define mid(l, r) ((l + r) &gt;&gt; 1)#define MXN 10007using namespace std;struct seg &#123; int x1, x2, y, atag; seg() &#123;x1 = x2 = y = atag = 0;&#125; seg(int a, int b, int c, int d):x1(a),x2(b),y(c),atag(d) &#123;&#125; bool operator&lt;(const seg &amp;b) const &#123; return y == b.y ? atag &gt; b.atag : y &lt; b.y; &#125;&#125; ss[MXN];int cnt[20000 &lt;&lt; 2 | 7], lne[20000 &lt;&lt; 2 | 7];bool lbd[20000 &lt;&lt; 2 | 7], rbd[20000 &lt;&lt; 2 | 7];int stree[20000 &lt;&lt; 2 | 7];inline void pushup(int root, int l, int r) &#123; if (cnt[root]) &#123; lbd[root] = rbd[root] = true; stree[root] = r - l + 1; lne[root] = 1; &#125; else if (l == r) &#123; lbd[root] = rbd[root] = false; lne[root] = stree[root] = 0; &#125; else &#123; stree[root] = stree[lson(root)] + stree[rson(root)]; lne[root] = lne[lson(root)] + lne[rson(root)]; if (rbd[lson(root)] &amp;&amp; lbd[rson(root)]) --lne[root]; lbd[root] = lbd[lson(root)]; rbd[root] = rbd[rson(root)]; &#125;&#125;void adddata(int root, int l, int r, int al, int ar, int data) &#123; if (l &gt; ar || r &lt; al) return; if (l &gt;= al &amp;&amp; r &lt;= ar) &#123; cnt[root] += data; pushup(root, l, r); return; &#125; adddata(lson(root), l, mid(l, r), al, ar, data); adddata(rson(root), mid(l, r) + 1, r, al, ar, data); pushup(root, l, r);&#125;int main() &#123; int n; while (~scanf(\"%d\", &amp;n)) &#123; int a, b, c, d; int m = 0; int lbd = 999999, rbd = -999999; for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%d %d %d %d\", &amp;a, &amp;b, &amp;c, &amp;d); lbd = std::min(lbd, a); rbd = std::max(rbd, c); ss[m++] = seg(a, c, b, 1); ss[m++] = seg(a, c, d, -1); &#125; sort(ss, ss + m); int last = 0, resu = 0; for (int i = 0; i &lt; m; ++i) &#123; adddata(1, lbd, rbd - 1, ss[i].x1, ss[i].x2 - 1, ss[i].atag); if (i != m - 1) resu += (lne[1] &lt;&lt; 1) * (ss[i + 1].y - ss[i].y); resu += std::abs(stree[1] - last); last = stree[1]; &#125; printf(\"%d\\n\", resu); &#125;&#125;","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"学习","slug":"学习","permalink":"http://cjsoft.github.io/tags/学习/"},{"name":"算法","slug":"算法","permalink":"http://cjsoft.github.io/tags/算法/"},{"name":"计算几何","slug":"计算几何","permalink":"http://cjsoft.github.io/tags/计算几何/"}]},{"title":"这么长时间没出岔子真是奇迹","date":"2016-05-01T07:13:12.000Z","path":"2016/05/01/这么长时间没出岔子真是奇迹/","text":"今天有一发提交莫名其妙的MLE了，题目内存上限10M，不过根据计算我的内存应该只消耗1M多一点。像下图一样处理，问题解决woc！！、我以前一直都不加括号的啊，这么长时间没有因为这件事情爆零（说不定有）真是奇迹、、、","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"Wallace Chu 的线段树风格","date":"2016-04-30T15:59:58.000Z","path":"2016/04/30/Wallace-Chu-的线段树风格/","text":"tag中存储的是左右子树中stree的待加的单位值，也就是说当一个节点他的祖先tag全为0时，我们保证它的stree值是准确的。 除此之外pushdown/update的时机需要注意，一个是在query/edit中对左右子树递归之前进行pushdown，另一个是add区间左右子树都递归的add之后回溯的时候update。据此，我们可以得出，每次add之后，所有被新打上tag的节点的祖先都会被pushdown一次，tag会被清空。 注意pushdown中判断l != r，否则会引发RE123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define lson(x) (x &lt;&lt; 1)#define rson(x) (x &lt;&lt; 1 | 1)#define update(x) (stree[x] = stree[x &lt;&lt; 1] + stree[x &lt;&lt; 1 | 1])#define mid(l, r) ((l + r) &gt;&gt; 1)using namespace std;typedef long long ll;int n;int q;ll stree[1000007];ll tag[1000007];ll raw[1000007];void build(int root, int l, int r) &#123; if (l == r) &#123; stree[root] = raw[l]; return; &#125; build(lson(root), l, mid(l, r)); build(rson(root), mid(l, r) + 1, r); update(root);&#125;void pushdown(int root, int l, int r) &#123; if (l == r) return; if (tag[root]) &#123; tag[lson(root)] += tag[root]; tag[rson(root)] += tag[root]; stree[lson(root)] += tag[root] * (mid(l, r) - l + 1); stree[rson(root)] += tag[root] * (r - mid(l, r)); tag[root] = 0; &#125; // update(root);&#125;ll query(int root, int l, int r, int ql, int qr) &#123; if (l &gt; qr || r &lt; ql) return 0; if (l &gt;= ql &amp;&amp; r&lt;= qr) return stree[root]; pushdown(root, l, r); return query(lson(root), l, mid(l, r), ql, qr) + query(rson(root), mid(l, r) + 1, r, ql, qr);&#125;void add(int root, int l, int r, int al, int ar, ll dataadd) &#123; if (l &gt; ar || r &lt; al) return; if (l &gt;= al &amp;&amp; r &lt;= ar) &#123; tag[root] += dataadd; stree[root] += (r - l + 1) * dataadd; return; &#125; pushdown(root, l, r); add(lson(root), l, mid(l, r), al, ar, dataadd); add(rson(root), mid(l, r) + 1, r, al, ar, dataadd); update(root);&#125;int main() &#123; int a, b, x, y; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld\", raw + i); &#125; build(1, 1, n); scanf(\"%d\", &amp;q); while (q--) &#123; scanf(\"%d %d %d\", &amp;x, &amp;a, &amp;b); if (x == 1) &#123; scanf(\"%d\", &amp;y); add(1, 1, n, a, b, y); &#125; else &#123; printf(\"%lld\\n\", query(1, 1, n, a, b)); &#125; &#125; return 0;&#125;","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://cjsoft.github.io/tags/数据结构/"},{"name":"树","slug":"树","permalink":"http://cjsoft.github.io/tags/树/"}]},{"title":"树链剖分小结","date":"2016-04-30T15:59:57.000Z","path":"2016/04/30/树链剖分/","text":"一句话，通过一种略微有些贪心思想的hash方法，把树上节点散列到一段连续区间上。通过某个节点的SCC（为该节点后代节点个数 + 1）值来确定他父亲的大胖儿子，连续的大胖儿子在散列区间上是连续的，在处理连续大胖儿子的维护上，我们可以用其他数据结构例如BIT或者ST或者SegTree这种工具来加速我们对树上信息的维护过程。 一些名词SCC:该节点后代节点个数 + 1大胖儿子:某节点SCC最大的儿子就是他的大胖儿子小瘦儿子:某节点SCC不是最大的儿子就是他的小瘦儿子。换言之，这个节点的儿子除了大胖儿子之外，其他所有儿子都是小瘦儿子深度:不解释爸爸:不解释重链：相互之间深度连续的且具有亲缘关系的大胖儿子（就是每个节点都是大胖儿子并且深度各不相同的连续的链）轻链：不是重链的链，这里探讨它的意义不大，因为轻链的长度最多不会超过两个节点散列值:某个节点在被散列到的连续区间上的位置反向散列值:某个散列值所对应的原节点（的节点号）不是必须的重链头：某条重链中深度最小的大胖儿子 一些重要性质 由定义得一个节点的大胖儿子只有一个 一条重链只会有一个重链头 正文 1. 精髓的前二分之一 首先，我们要知道所有节点的SCC、大胖儿子、深度、爸爸都是啥，这个通过一次dfs可以搞出来。为了同我写过的代码风格一致，建议使老祖宗也就是根节点的爸爸为0而不是他自己。代码见下文附录的dfs_1 通过第二次dfs算出每个节点的散列值和反向散列值，以及重链头。 为当前节点分配散列值，并保存反向散列值。顺序增加就好（就是1、2、3、4…） 对儿子们进行dfs，注意，一定要优先对大胖儿子进行dfs，大胖儿子的重链头就是他爸爸的重链头。剩下的小瘦儿子dfs顺序随意，他们的重链头是他们自己 树剖的精髓的二分之一已经学会了！、 然后利用散列值或者反向散列值乱搞（例如对线段钩进行初始化建钩操作 雾） 2. 精髓的后二分之一树剖的另一半精髓是树上操作和查询的快速乱搞，大概的核心思想是利用重链在散列区间上的连续特性进行加速优化 例如，给定一棵树，求任意两点间节点（包括这两个点）的权值和我们就可以在处理这两个节点时利用求和线段钩直接求出重链上节点的权值和，将结果合并即可。 如果需要单节点修改权值的话直接利用散列值在线段钩上修改即可。如果需要双节点间（包括这两个节点）的权值加减或者全部修改成某个指定值，方法与查询类似，对每一条重链进行修改即可。 如何合并重链？例如给定两个节点，我们要对其间的所有重链进行某一操作或查询。设节点分别为l, r 有函数1234depth(x); //返回节点深度head(x); //返回节点重链头fa(x); //返回节点爸爸locator(x); //返回节点的散列值 当head(l) != head(r)即两节点不处在同一重链上时，进行下列操作 我们找depth(head(x))值较大，即重链头深度较大的那个点，使它为l，另一个为r（相当于swap）。 利用locator(x)找到重链在散列区间上的位置，使用线段钩或其他结构对这段区间进行操作或查询。如果是查询的话注意合并查询结果。 使l = fa(head(l)) 此时l和r在同一条重链上，再次对这条重链上的l和r节点（包括l和r）所构成的区间进行相同的操作或查询（如果你的结构不支持自动将操作查询的区间l，r normalize的话，注意使locator(x)较小的节点的locator值作为区间左界，另一个作为右界，不然容易RE） 附录ZJOI 2008 树的统计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183/** * Copyright 2015 CJSoft */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define CLEAR(x) memset(x, 0, sizeof(x))const int MXN = 30007;typedef long long ll; //NOLINTint n;struct edge &#123; int to; explicit edge(int a) &#123; to = a; &#125;&#125;;std::vector &lt;int&gt; v[MXN];int nodeweight[MXN];int c_sub_nodes[MXN];int fa[MXN];int h_son[MXN];int head[MXN];int dep[MXN];int locator[MXN];int revlocator[MXN];int tot = 1;void dfs_1(int root, int from, int depth) &#123; if (!from) &#123; fa[root] = 0; &#125; else &#123; fa[root] = from; &#125; dep[root] = depth; c_sub_nodes[root] = 1; h_son[root] = 0; for (int i = 0; i &lt; v[root].size(); ++i) &#123; if (v[root][i] == from) continue; dfs_1(v[root][i], root, depth + 1); c_sub_nodes[root] += c_sub_nodes[v[root][i]]; if (c_sub_nodes[v[root][i]] &gt;= c_sub_nodes[h_son[root]]) &#123; h_son[root] = v[root][i]; &#125; &#125;&#125;void dfs_2(int root, int hd) &#123; locator[root] = tot; revlocator[tot++] = root; head[root] = hd; if (h_son[root]) &#123; dfs_2(h_son[root], hd); &#125; for (int i = 0; i &lt; v[root].size(); ++i) &#123; if (v[root][i] == h_son[root] || v[root][i] == fa[root]) continue; dfs_2(v[root][i], v[root][i]); &#125;&#125;struct RMQ_QJH_XDS &#123; ll stree_rmq[MXN * 4 + 7]; ll stree_qjh[MXN * 4 + 7]; RMQ_QJH_XDS() &#123; std::fill(stree_rmq, stree_rmq + MXN * 4 + 7, - 1e9); std::fill(stree_qjh, stree_qjh + MXN * 4 + 7, 0); &#125; inline int lson(int root) &#123; return root &lt;&lt; 1; &#125; inline int rson(int root) &#123; return root &lt;&lt; 1 | 1; &#125; void build(int root, int l, int r) &#123; if (l == r) &#123; stree_rmq[root] = nodeweight[revlocator[l]]; stree_qjh[root] = nodeweight[revlocator[l]]; return; &#125; int m = (l + r) &gt;&gt; 1; build(lson(root), l, m); build(rson(root), m + 1, r); stree_rmq[root] = std::max( stree_rmq[lson(root)], stree_rmq[rson(root)]); stree_qjh[root] = stree_qjh[lson(root)] + stree_qjh[rson(root)]; &#125; ll rmq_query(int root, int l, int r, int queryl, int queryr) &#123; if (queryl &gt; queryr) std::swap(queryl, queryr); if (queryl &gt; r || queryr &lt; l) return - 1e9; if (queryl &lt;= l &amp;&amp; queryr &gt;= r) return stree_rmq[root]; int m = (l + r) &gt;&gt; 1; return std::max(rmq_query(lson(root), l, m, queryl, queryr), rmq_query(rson(root), m + 1, r, queryl, queryr)); &#125; ll qjh_query(int root, int l, int r, int queryl, int queryr) &#123; if (queryl &gt; queryr) std::swap(queryl, queryr); if (queryl &gt; r || queryr &lt; l) return 0; if (queryl &lt;= l &amp;&amp; queryr &gt;= r) return stree_qjh[root]; int m = (l + r) &gt;&gt; 1; return qjh_query(lson(root), l, m, queryl, queryr) + qjh_query(rson(root), m + 1, r, queryl, queryr); &#125; void edit(int root, int l, int r, int pos, ll new_data) &#123; if (l == r) &#123; stree_qjh[root] = new_data; stree_rmq[root] = new_data; return; &#125; if (pos &gt; ((l + r) &gt;&gt; 1)) &#123; edit(rson(root), ((l + r) &gt;&gt; 1) + 1, r, pos, new_data); &#125; else &#123; edit(lson(root), l, (l + r) &gt;&gt; 1, pos, new_data); &#125; stree_rmq[root] = std::max(stree_rmq[lson(root)], stree_rmq[rson(root)]); stree_qjh[root] = stree_qjh[lson(root)] + stree_qjh[rson(root)]; &#125;&#125; slpf;ll tree_rmq_query(int l, int r) &#123; ll resu = - 1e9; while (head[l] != head[r]) &#123; if (dep[head[l]] &lt; dep[head[r]]) std::swap(l, r); resu = std::max(resu, slpf.rmq_query(1, 1, tot - 1, locator[head[l]], locator[l])); l = fa[head[l]]; &#125; if (locator[l] &gt; locator[r]) std::swap(l, r); resu = std::max(resu, slpf.rmq_query(1, 1, tot - 1, locator[l], locator[r])); return resu;&#125;ll tree_qjh_query(int l, int r) &#123; ll resu = 0; while (head[l] != head[r]) &#123; if (dep[head[l]] &lt; dep[head[r]]) std::swap(l, r); resu += slpf.qjh_query(1, 1, tot - 1, locator[head[l]], locator[l]); l = fa[head[l]]; &#125; if (locator[l] &gt; locator[r]) std::swap(l, r); resu += slpf.qjh_query(1, 1, tot - 1, locator[l], locator[r]); return resu;&#125;int main() &#123; CLEAR(nodeweight); CLEAR(c_sub_nodes); CLEAR(fa); CLEAR(h_son); CLEAR(head); CLEAR(dep); CLEAR(locator); CLEAR(revlocator); scanf(\"%d\", &amp;n); int tempa, tempb; for (int i = 0; i &lt; n - 1; ++i) &#123; scanf(\"%d %d\", &amp;tempa, &amp;tempb); v[tempa].push_back(tempb); v[tempb].push_back(tempa); &#125; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;nodeweight[i]); &#125; head[1] = 1; dfs_1(1, 0, 1); dfs_2(1, 1); slpf.build(1, 1, tot - 1); int q; char tc[11]; scanf(\"%d\", &amp;q); for (int i = 0; i &lt; q; ++i) &#123; CLEAR(tc); scanf(\"%s %d %d\", tc, &amp;tempa, &amp;tempb); if (tc[1] == 'M') &#123; ll asd = tree_rmq_query(tempa, tempb); printf(\"%lld\\n\", asd); &#125; else if (tc[1] == 'S') &#123; printf(\"%lld\\n\", tree_qjh_query(tempa, tempb)); &#125; else &#123; slpf.edit(1, 1, tot - 1, locator[tempa], tempb); nodeweight[tempa] = tempb; &#125; &#125;&#125;","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"图论","slug":"图论","permalink":"http://cjsoft.github.io/tags/图论/"},{"name":"算法","slug":"算法","permalink":"http://cjsoft.github.io/tags/算法/"}]},{"title":"tarjan求强连通分量","date":"2016-04-30T15:59:56.000Z","path":"2016/04/30/tarjan求强连通分量/","text":"利用dfs顺序来确定各个点之间的关系 正文 我们有一个栈，还有一个low数组和一个dfn数组，其中low数组记录从该节点出发所能到达的dfs序最小的节点的编号（这个点一定会是他的祖先，之后说明原因），dfn数组记录的是该节点的dfs序 在一个联通块上，选取一点开始dfs，记录dfs序，压该点入栈。遍历从该点出发的边： 1.若到达点不在栈中，对到达点进行dfs，之后用到达点的low值更新当前节点的low值（如果到达点的low值更小的话） 2.若到达节点在栈中，用到达节点的dfn值更新当前节点的low值 为什么这么做呢？1不用解释，2如果一个节点的目标节点在栈中，那么目标节点的一定是它的祖先，因为每个节点至多入栈一次，越靠近栈底的元素越老，肯定是处在栈顶的当前节点的祖先。 若当前节点的dfn值与low值相同，说明当前节点是一个环中最靠近的祖先的节点，此时连续弹栈，直到当前节点被弹出栈。所弹节点就是一个强连通分量上的全部点。 PS：若图上有块是不连通的，那么需要多次启动dfs过程完成整张图的求强连通分量过程。","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"图论","slug":"图论","permalink":"http://cjsoft.github.io/tags/图论/"},{"name":"算法","slug":"算法","permalink":"http://cjsoft.github.io/tags/算法/"}]},{"title":"并查集","date":"2016-04-30T15:59:55.000Z","path":"2016/04/30/并查集/","text":"一句话，并查集本质上是一个森林，最基本的查询是询问某个节点所在树的树根是什么。显然的，树根相同的节点在同一集合之中。 简单的并查集实现起来非常简单，查询只要不断的找爸爸找到树根就可以了，两个集合求并只要将一个集合的树根接到另一个集合任意一个节点上就可以了（通常直接接在另一个集合的树根上）1234567891011121314struct unionSet &#123; int fa[MXN]; unionSet() &#123; for (int i = 0; i &lt; MXN; ++i) &#123; fa[i] = i; &#125; &#125; int getfa(int x) &#123; return fa[x] == x ? x : fa[x] = getfa(fa[x]); &#125; void union(int a, int b) &#123; fa[getfa(a)] = getfa(b); &#125;&#125;; 带权并查集 我们要知道什么情况下可以使用带权并查集解决问题。通常，当两个元素之间的关系可以量化，并且关系是可以合并的（当我们已知a与b的关系，又知a和c的关系，我们可以求得b和c的关系，我们称这种关系是可以合并的）时，是可以用带权并查集来维护元素之间的关系的。当我们只知道元素之间的相对关系时，带权并查集或许能够解决这个问题。 我们要知道这个权的意义。带权并查集每个元素的权通常描述的是这个元素和他在并查集中的爸爸之间的关系。 我们要知道如何路径压缩。这种关系如何合并，路径压缩时权值就怎样压缩。 我们要知道如何求并集。带权并查集的并集操作接树根的顺序非常重要，这取决于具体的问题。一点建议是每次并集时只进行一次getfa操作，避免因为getfa触发的路径压缩影响程序的正确性。 我们要知道两个元素是否属于同一集合的意义是什么。两个元素在同一个集合当中意味着他们之间的关系是已知的，可以查询的。反之则是未知的，不可查询，你可以添加这两个元素之间的关系，并将两个集合求并（如4.）","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://cjsoft.github.io/tags/数据结构/"},{"name":"树","slug":"树","permalink":"http://cjsoft.github.io/tags/树/"}]},{"title":"简单凸包求法","date":"2016-04-30T15:59:54.000Z","path":"2016/04/30/简单凸包求法/","text":"首先，求极角需要注意，为了方便，当atan2值小于0时，atan2值加上2π作为极角大小，这样做对于下面的做法来说是比较方便的 1234567inline double atan3(double a,double b )&#123; double t=atan2(a,b); if(t&lt;0)&#123; t+=2*M_PI; &#125; return t;&#125; 选取最下方的最左侧的点作为凸包初始点，将其他的点按照与这个点的连线极角大小进行排序。建议以极角作为第一关键字，距这个点的欧氏距离作为第二逆序关键字，这样我们会减轻接下来去重工作的负担。 按极角顺序遍历除初始点以外的所有点，若有极角相同的点，保留与初始点距离最大的那一个。由于1中我们有第二关键字，所以这里保留极角相同的第一个点即可。（注意如果是原址删除多余点的话，注意删除多余点之后点的顺序可能发生变化。其实这个问题和凸包本身没什么关系，只是自己手残写残，没有发现这个问题而已） 将初始点和极角最小的角压入凸包栈中。同时向偏角栈中压入0和极角最小角的极角（这个都压0也可以） 按极角顺序遍历剩余的所有点，对他们进行以下操作： 循环进行这个操作计算当前点与凸包栈栈顶元素连线的极角大小，如果这个值小于偏角栈栈顶元素，说明凸包栈栈顶的点是多余的，因为沿凸包边逆时针走，每次都不会向右转，如果偏角先大后小，说明向右转了，我们就需要把向右转的点和它对应的偏角弹出。当这个操作不能进行后，继续。 将当前点和当前点与凸包栈栈顶元素连线的极角大小分别压入凸包栈和偏角栈中。 你已经得到了按顺序排列在凸包栈中的凸包边上的所有点了，凸包得求。 PS: 好像只有我一个人傻乎乎的用atan来求极角，别人都是用叉积来算的。","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://cjsoft.github.io/tags/算法/"},{"name":"计算几何","slug":"计算几何","permalink":"http://cjsoft.github.io/tags/计算几何/"}]},{"title":"tarjan求割点和桥","date":"2016-04-30T15:59:53.000Z","path":"2016/04/30/tarjan求割点和桥/","text":"求割点满足以下任意之一的条件的点u即为割点： u为树根，且u有多余一个的儿子 存在边(u, v)，v为u的儿子，且dfn(u) &lt;= low(v) 求桥边(u, v)，v为u的儿子， 且dfn(u) &lt; low(v)","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"图论","slug":"图论","permalink":"http://cjsoft.github.io/tags/图论/"},{"name":"算法","slug":"算法","permalink":"http://cjsoft.github.io/tags/算法/"}]},{"title":"BKDR-hash","date":"2016-04-30T15:59:52.000Z","path":"2016/04/30/BKDR-hash/","text":"123456789101112unsigned int BKDRHash(char *str)&#123; unsigned int seed = 131; // 31 131 1313 13131 131313 etc.. unsigned int hash = 0; while (*str) &#123; hash = hash * seed + (*str++); &#125; return (hash &amp; 0x7FFFFFFF);&#125;","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"哈希","slug":"哈希","permalink":"http://cjsoft.github.io/tags/哈希/"},{"name":"算法","slug":"算法","permalink":"http://cjsoft.github.io/tags/算法/"}]},{"title":"非确定性算法","date":"2016-04-30T15:59:49.000Z","path":"2016/04/30/非确定性算法/","text":"虽然在OI中并不实用，但是这种算法本身具有非常大的实用价值。事实上，一些非确定性算法在现实中的应用比对应的确定性算法要广泛的多。下面介绍两种非确定性算法。 1. Miller Rabbin Primality TestMR素性测试是一个常用的非确定性素数检查算法，在OI中也有一定的应用，它的复杂度是O(log(n))，远远小于确定性的AKS，复杂度为O(log(n)^6 )，和朴素枚举，复杂度为O(sqrt(n))。MR素性测试的失误率取决于测试集。当随机选取测试集时，它的错误率为4^(-len(testSet))，一个精心选取的测试集可以保证一定范围内的测试的结果的完全正确，这也是他被广泛应用的原因。下面给出一个Python 2.7的MR测试样例代码，其中使用的测试集保证1到1e16范围内结果无误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#coding=utf-8#Copyright 2015 CJSofttestSet = &#123;2, 3, 7, 13, 61, 24251&#125;def qpow(x, y, n): resu = 1 while (y &gt; 0): if (y &amp; 1 == 1): resu = (resu * x) % n y = y &gt;&gt; 1 x = (x * x) % n return resudef MillerRabinTest(a, n, d, s): # True if it's likely to be a prime. if (n == 2 or n == a): return True if ((n &amp; 1) == 0): return False for r in xrange(s): if (qpow(a, d, n) == 1 or (qpow(a, (1 &lt;&lt; r) * d, n) in &#123;-1, n - 1&#125;)): return True return Falsedef isPrime(x): global testSet if (x &lt; 2): return False tint = x - 1 s = 0 while (tint &amp; 1 == 0): tint = tint &gt;&gt; 1 s = s + 1 for i in testSet: if not(MillerRabinTest(i, x, tint, s)): return False return Trueif (__name__ == \"__main__\"): import sys if (len(sys.argv) &gt; 1): for i in sys.argv[1:]: try: print isPrime(int(i)) except BaseException: print \"Illegal input\" else: while True: try: a = int(input(\"&gt;&gt;&gt; \")) print isPrime(a) except KeyboardInterrupt: print \"Bye!\" sys.exit(0) except BaseException: print \"Illegal input\" 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Copyright 2015 CJSoft * This piece of code have somethings to * do with primality test. */#include &lt;iostream&gt;#include &lt;cstdio&gt;typedef long long ll; //NOLINTll quickPow(ll x, ll y, ll MOD) &#123; ll resu = 1; while (y &gt; 0) &#123; if (y &amp; 1) resu = (resu * x) % MOD; y &gt;&gt;= 1; x = (x * x) % MOD; &#125; return resu;&#125;bool MillerRabbinTest(ll a, ll n, ll d, ll s) &#123; if (n == 2 || n == a) return true; if (!(n &amp; 1)) return false; if (quickPow(a, d, n) == 1) return true; for (int i = 0; i &lt; s; ++i) &#123; if (quickPow(a, (1 &lt;&lt; i) * d, n) == n - 1) return true; &#125; return false;&#125;bool isPrime(ll x) &#123; const ll testCase[] = &#123;2, 3, 7, 13, 61, 24251&#125;; if (x &lt; 2) return false; ll tint = x - 1; ll s = 0; while (!(tint &amp; 1)) &#123; tint &gt;&gt;= 1; ++s; &#125; for (int i = 0; i &lt; sizeof(testCase) / sizeof(ll); ++i) if (!MillerRabbinTest(testCase[i], x, tint, s)) return false; return true;&#125;int main() &#123; return 0;&#125; 2. Bloom FilterBloom Filter算法非常简单易懂，他被广泛的应用在爬虫技术中。它的功能是确定一个元素是否在集合之中，优势在于只使用非常少的空间，就可以维护数额巨大的元素的信息。它只能确定一个元素是否在一个集合中。然而内存、时间、准确性三者往往在一定程度上是守恒的，使用越少的内存，BF的准确性就越低。它的复杂度是O(1)的。下面说一下它的原理。他就是个hash加强版。 当我们查询一个元素是否在集合中，我们使用少至几个多至几十个的不同的hash函数得出许多元素的hash值（要实现的话hash函数可以使用几个固定的，外加一些随机生成的hash函数，这个在第一次使用BF之前就要做，除此之外还要准备相应数目的bitset），检查每个函数对应的bitset的对应位上是否为1，如果所有对应位的值都为1的话，说明这个元素有可能在这个集合中，反之一定不再这个集合中。 当我们将一个元素加入到集合中的话，我们算出那些hash值，set一下每个hash函数对应的bitset上hash值对应位即可（也就是赋成1） 关于元素的移除。BF有个变种叫做Counting Bloom Filter，看了名字大概就明白怎么回事了吧=w=。详情请去问问神奇海螺吧、","tags":[{"name":"OI","slug":"OI","permalink":"http://cjsoft.github.io/tags/OI/"},{"name":"其他","slug":"其他","permalink":"http://cjsoft.github.io/tags/其他/"},{"name":"算法","slug":"算法","permalink":"http://cjsoft.github.io/tags/算法/"}]},{"title":"我好害怕","date":"2016-04-30T08:06:51.000Z","path":"2016/04/30/我好害怕/","text":"我惶恐啊、","tags":[{"name":"动态","slug":"动态","permalink":"http://cjsoft.github.io/tags/动态/"}]},{"title":"fav.扫描线","date":"2016-04-30T06:50:09.000Z","path":"2016/04/30/fav-扫描线/","text":"http://openinx.github.io/2013/01/01/plane-sweep-thinking/","tags":[{"name":"fav","slug":"fav","permalink":"http://cjsoft.github.io/tags/fav/"}]}]